#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conch's Blessing XML Generator
Auto generated by conch_blessing_items.lua
"""

import re
import os
import xml.etree.ElementTree as ET
from xml.dom import minidom

def find_matching_brace(content, start_pos):
    """detect the matching brace position"""
    brace_count = 0
    pos = start_pos
    
    while pos < len(content):
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
            if brace_count == 0:
                return pos
        pos += 1
    
    return -1

def parse_pool_array(pool_data):
    """parse the pool array"""
    pools = []
    
    # RoomType.ROOM_XXX 패턴 찾기
    pool_matches = re.findall(r'RoomType\.ROOM_(\w+)', pool_data)
    for pool in pool_matches:
        pools.append(pool)
    
    return pools

def parse_lua_file(file_path):
    """parse the lua file and extract the item information"""
    items = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: {file_path} file not found.")
        return items
    
    print(f"file length: {len(content)} characters")
    
    # remove comments (-- starting line)
    lines = []
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped.startswith('--'):
            lines.append(line)
    
    content = '\n'.join(lines)
    
    # find the ItemData table
    itemdata_pattern = r'ConchBlessing\.ItemData\s*=\s*{'
    itemdata_match = re.search(itemdata_pattern, content)
    
    if not itemdata_match:
        print("ItemData table not found.")
        print("file content:")
        print(content[:500])
        return items
    
    start_pos = itemdata_match.end() - 1  # { position
    end_pos = find_matching_brace(content, start_pos)
    
    if end_pos == -1:
        print("ItemData table end not found.")
        return items
    
    itemdata_content = content[start_pos+1:end_pos]
    print(f"ItemData content: {itemdata_content[:200]}...")
    
    # find the item pattern (LIVE_EYE = { ... })
    item_pattern = r'(\w+)\s*=\s*{'
    item_matches = list(re.finditer(item_pattern, itemdata_content))
    
    print(f"found item matches: {len(item_matches)}")
    
    for match in item_matches:
        name = match.group(1)
        print(f"processing item: {name}")
        
        # find the item block start and end
        item_start = match.end() - 1  # { position
        item_end = find_matching_brace(itemdata_content, item_start)
        
        if item_end == -1:
            print(f"  warning: {name} item block end not found.")
            continue
        
        item_data = itemdata_content[item_start+1:item_end]
        print(f"  item data: {item_data[:100]}...")
        
        item_info = {}
        
        # extract id
        id_match = re.search(r'id\s*=\s*Isaac\.GetItemIdByName\("([^"]+)"\)', item_data)
        if id_match:
            item_info['id'] = id_match.group(1)
            print(f"  ID: {item_info['id']}")
        
        # extract name
        name_match = re.search(r'name\s*=\s*"([^"]+)"', item_data)
        if name_match:
            item_info['name'] = name_match.group(1)
            print(f"  Name: {item_info['name']}")
        
        # extract type
        type_match = re.search(r'type\s*=\s*"([^"]+)"', item_data)
        if type_match:
            item_info['type'] = type_match.group(1)
            print(f"  Type: {item_info['type']}")
        
        # extract description
        desc_match = re.search(r'description\s*=\s*"([^"]+)"', item_data)
        if desc_match:
            item_info['description'] = desc_match.group(1)
            print(f"  Description: {item_info['description']}")
        
        # extract pool (array form)
        pool_match = re.search(r'pool\s*=\s*{([^}]+)}', item_data)
        if pool_match:
            pool_data = pool_match.group(1)
            item_info['pools'] = parse_pool_array(pool_data)
            print(f"  Pools: {item_info['pools']}")
        else:
            # support single pool form
            pool_match = re.search(r'pool\s*=\s*RoomType\.ROOM_(\w+)', item_data)
            if pool_match:
                item_info['pools'] = [pool_match.group(1)]
                print(f"  Pool: {item_info['pools']}")
        
        # extract weight
        weight_match = re.search(r'weight\s*=\s*([\d.]+)', item_data)
        if weight_match:
            item_info['weight'] = float(weight_match.group(1))
            print(f"  Weight: {item_info['weight']}")
        
        # extract DecreaseBy
        decrease_by_match = re.search(r'DecreaseBy\s*=\s*(\d+)', item_data)
        if decrease_by_match:
            item_info['DecreaseBy'] = int(decrease_by_match.group(1))
            print(f"  DecreaseBy: {item_info['DecreaseBy']}")
        
        # extract RemoveOn
        remove_on_match = re.search(r'RemoveOn\s*=\s*([\d.]+)', item_data)
        if remove_on_match:
            item_info['RemoveOn'] = float(remove_on_match.group(1))
            print(f"  RemoveOn: {item_info['RemoveOn']}")
        
        # extract quality
        quality_match = re.search(r'quality\s*=\s*(\d+)', item_data)
        if quality_match:
            item_info['quality'] = int(quality_match.group(1))
            print(f"  Quality: {item_info['quality']}")
        
        # extract tags
        tags_match = re.search(r'tags\s*=\s*"([^"]+)"', item_data)
        if tags_match:
            item_info['tags'] = tags_match.group(1)
            print(f"  Tags: {item_info['tags']}")
        
        # extract cache
        cache_match = re.search(r'cache\s*=\s*"([^"]+)"', item_data)
        if cache_match:
            item_info['cache'] = cache_match.group(1)
            print(f"  Cache: {item_info['cache']}")
        
        # extract hidden
        hidden_match = re.search(r'hidden\s*=\s*(true|false)', item_data)
        if hidden_match:
            item_info['hidden'] = hidden_match.group(1) == 'true'
            print(f"  Hidden: {item_info['hidden']}")
        
        # extract price (상점 가격)
        price_match = re.search(r'price\s*=\s*(\d+)', item_data)
        if price_match:
            item_info['price'] = int(price_match.group(1))
            print(f"  Price: {item_info['price']}")
        
        # extract devilprice (악마방 가격, 음수 값도 처리)
        devilprice_match = re.search(r'devilprice\s*=\s*(-?\d+)', item_data)
        if devilprice_match:
            item_info['devilprice'] = int(devilprice_match.group(1))
            print(f"  DevilPrice: {item_info['devilprice']}")
        
        # extract maxcharges
        maxcharges_match = re.search(r'maxcharges\s*=\s*(\d+)', item_data)
        if maxcharges_match:
            item_info['maxcharges'] = int(maxcharges_match.group(1))
            print(f"  MaxCharges: {item_info['maxcharges']}")
        
        # extract chargetype
        chargetype_match = re.search(r'chargetype\s*=\s*"([^"]+)"', item_data)
        if chargetype_match:
            item_info['chargetype'] = chargetype_match.group(1)
            print(f"  ChargeType: {item_info['chargetype']}")
        
        # extract hearts
        hearts_match = re.search(r'hearts\s*=\s*(-?\d+)', item_data)
        if hearts_match:
            item_info['hearts'] = int(hearts_match.group(1))
            print(f"  Hearts: {item_info['hearts']}")
        
        # extract maxhearts
        maxhearts_match = re.search(r'maxhearts\s*=\s*(-?\d+)', item_data)
        if maxhearts_match:
            item_info['maxhearts'] = int(maxhearts_match.group(1))
            print(f"  MaxHearts: {item_info['maxhearts']}")
        
        # extract blackhearts
        blackhearts_match = re.search(r'blackhearts\s*=\s*(\d+)', item_data)
        if blackhearts_match:
            item_info['blackhearts'] = int(blackhearts_match.group(1))
            print(f"  BlackHearts: {item_info['blackhearts']}")
        
        # extract soulhearts
        soulhearts_match = re.search(r'soulhearts\s*=\s*(\d+)', item_data)
        if soulhearts_match:
            item_info['soulhearts'] = int(soulhearts_match.group(1))
            print(f"  SoulHearts: {item_info['soulhearts']}")
        
        if item_info:
            items[name] = item_info
            print(f"  added item: {name}")
    
    return items

def create_items_xml(items, output_path):
    """create the items.xml file (mattpack format)"""
    root = ET.Element("items")
    root.set("gfxroot", "gfx/items/")
    root.set("version", "1")
    
    item_id_counter = 0
    
    for item_key, item_info in items.items():
        # determine the item type (use type if it exists, otherwise use maxcharges)
        item_type = item_info.get('type', 'passive')
        if not item_info.get('type') and item_info.get('maxcharges'):
            item_type = 'active'
        
        item_elem = ET.SubElement(root, item_type)
        
        item_elem.set("id", str(item_id_counter))
        item_elem.set("name", item_info.get('name', ''))
        item_elem.set("description", item_info.get('description', ''))
        item_elem.set("gfx", f"{item_key.lower()}.png")
        item_elem.set("quality", str(item_info.get('quality', 3)))
        item_elem.set("tags", item_info.get('tags', 'offensive'))
        
        # set additional attributes
        if item_info.get('cache'):
            item_elem.set("cache", item_info['cache'])
        
        if item_info.get('hidden'):
            item_elem.set("hidden", "true")
        
        if item_info.get('price'):
            item_elem.set("shopprice", str(item_info['price']))
        
        if item_info.get('devilprice'):
            item_elem.set("devilprice", str(item_info['devilprice']))
        
        if item_info.get('maxcharges'):
            item_elem.set("maxcharges", str(item_info['maxcharges']))
        
        if item_info.get('chargetype'):
            item_elem.set("chargetype", item_info['chargetype'])
        
        if item_info.get('hearts'):
            item_elem.set("hearts", str(item_info['hearts']))
        
        if item_info.get('maxhearts'):
            item_elem.set("maxhearts", str(item_info['maxhearts']))
        
        if item_info.get('blackhearts'):
            item_elem.set("blackhearts", str(item_info['blackhearts']))
        
        if item_info.get('soulhearts'):
            item_elem.set("soulhearts", str(item_info['soulhearts']))
        
        item_id_counter += 1
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"items.xml created: {output_path}")

def create_itempools_xml(items, output_path):
    """create the itempools.xml file (mattpack format)"""
    root = ET.Element("ItemPools")
    
    # pool type mapping
    pool_mapping = {
        'TREASURE': 'treasure',
        'SHOP': 'shop',
        'SECRET': 'secret',
        'SUPERSECRET': 'ultraSecret',
        'DEVIL': 'devil',
        'ANGEL': 'angel',
        'BOSS': 'boss',
        'MINIBOSS': 'miniboss'
    }
    
    # group items by pool
    pool_items = {}
    for item_key, item_info in items.items():
        pools = item_info.get('pools', ['TREASURE'])
        weight = item_info.get('weight', 1.0)
        decrease_by = item_info.get('DecreaseBy', 1)
        remove_on = item_info.get('RemoveOn', 0.1)
        
        for pool_name in pools:
            pool_type = pool_mapping.get(pool_name, 'treasure')
            
            if pool_type not in pool_items:
                pool_items[pool_type] = []
            
            pool_items[pool_type].append({
                'name': item_info.get('name', ''),
                'weight': weight,
                'DecreaseBy': decrease_by,
                'RemoveOn': remove_on
            })
    
    # create each pool
    for pool_type, items_list in pool_items.items():
        pool_elem = ET.SubElement(root, "Pool")
        pool_elem.set("Name", pool_type)
        
        for item in items_list:
            item_elem = ET.SubElement(pool_elem, "Item")
            item_elem.set("Name", item['name'])
            item_elem.set("Weight", str(item['weight']))
            item_elem.set("DecreaseBy", str(item['DecreaseBy']))
            item_elem.set("RemoveOn", str(item['RemoveOn']))
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"itempools.xml created: {output_path}")

def main():
    """main function"""
    lua_file = "scripts/conch_blessing_items.lua"
    items_xml_path = "content/items.xml"
    itempools_xml_path = "content/itempools.xml"
    
    print("Conch's Blessing XML Generator started...")
    print(f"reading Lua file: {lua_file}")
    
    # parse the Lua file
    items = parse_lua_file(lua_file)
    
    if not items:
        print("warning: no items found.")
        return
    
    print(f"found items: {len(items)}")
    for name, info in items.items():
        print(f"  - {name}: {info.get('name', 'Unknown')} (ID: {info.get('id', 'Unknown')})")
    
    # create the XML files
    create_items_xml(items, items_xml_path)
    create_itempools_xml(items, itempools_xml_path)
    
    print("XML files created!")

if __name__ == "__main__":
    main() 