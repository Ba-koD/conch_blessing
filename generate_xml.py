#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conch's Blessing XML Generator
Auto generated by conch_blessing_items.lua
"""

import re
import os
import xml.etree.ElementTree as ET
from xml.dom import minidom

def find_matching_brace(content, start_pos):
    """detect the matching brace position"""
    brace_count = 0
    pos = start_pos
    
    while pos < len(content):
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
            if brace_count == 0:
                return pos
        pos += 1
    
    return -1

def parse_pool_array(pool_data):
    """parse the pool array with support for both simple and complex pool entries"""
    pools = []
    
    print(f"  Parsing pool data (full):")
    print(f"  '{pool_data}'")
    
    # 복잡한 풀 엔트리들을 먼저 찾아서 처리
    # {RoomType.ROOM_XXX, weight=1.0, decrease_by=1, remove_on=0.1} 형태
    # 여러 줄에 걸쳐 있을 수 있으므로 전체 텍스트에서 찾기
    complex_pattern = r'\{RoomType\.ROOM_(\w+),\s*weight=([\d.]+),\s*decrease_by=(\d+),\s*remove_on=([\d.]+)\}'
    complex_matches = re.findall(complex_pattern, pool_data, re.DOTALL)
    
    print(f"  Found {len(complex_matches)} complex matches: {complex_matches}")
    
    for match in complex_matches:
        room_type = match[0]
        weight = float(match[1])
        decrease_by = int(match[2])
        remove_on = float(match[3])
        
        pool_entry = f"ROOM_{room_type}"
        pool_dict = {pool_entry: True, 'weight': weight, 'decrease_by': decrease_by, 'remove_on': remove_on}
        pools.append(pool_dict)
        print(f"    Found complex pool: {pool_dict}")
    
    # 단순 풀 엔트리들 찾기 (복잡한 엔트리로 처리되지 않은 것들만)
    simple_matches = re.findall(r'RoomType\.ROOM_(\w+)', pool_data)
    for match in simple_matches:
        pool_entry = f"ROOM_{match}"
        # 이미 복잡한 엔트리로 처리되지 않은 경우만 추가
        if not any(isinstance(p, dict) and p.get(pool_entry) for p in pools):
            pools.append(pool_entry)
            print(f"    Added simple pool: {pool_entry}")
    
    print(f"  Final pools: {pools}")
    return pools

def parse_lua_file(file_path):
    """parse the lua file and extract the item information"""
    items = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: {file_path} file not found.")
        return items
    
    print(f"file length: {len(content)} characters")
    
    # remove comments (-- starting line)
    lines = []
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped.startswith('--'):
            lines.append(line)
    
    content = '\n'.join(lines)
    
    # find the ItemData table
    itemdata_pattern = r'ConchBlessing\.ItemData\s*=\s*{'
    itemdata_match = re.search(itemdata_pattern, content)
    
    if not itemdata_match:
        print("ItemData table not found.")
        print("file content:")
        print(content[:500])
        return items
    
    start_pos = itemdata_match.end() - 1  # { position
    end_pos = find_matching_brace(content, start_pos)
    
    if end_pos == -1:
        print("ItemData table end not found.")
        return items
    
    itemdata_content = content[start_pos+1:end_pos]
    print(f"ItemData content: {itemdata_content[:200]}...")
    
    # find the item pattern (LIVE_EYE = { ... })
    # 최상위 레벨의 아이템만 찾도록 수정
    item_pattern = r'(\w+)\s*=\s*{'
    item_matches = list(re.finditer(item_pattern, itemdata_content))
    
    print(f"found item matches: {len(item_matches)}")
    
    for match in item_matches:
        name = match.group(1)
        print(f"processing item: {name}")
        
        # find the item block start and end
        item_start = match.end() - 1  # { position
        item_end = find_matching_brace(itemdata_content, item_start)
        
        if item_end == -1:
            print(f"  warning: {name} item block end not found.")
            continue
        
        item_data = itemdata_content[item_start+1:item_end]
        print(f"  item data: {item_data[:100]}...")
        
        # 아이템이 아닌 중첩된 테이블인지 확인
        # id, name, type 중 하나라도 있으면 아이템으로 간주
        has_id = re.search(r'id\s*=', item_data)
        has_name = re.search(r'name\s*=', item_data)
        has_type = re.search(r'type\s*=', item_data)
        
        if not (has_id or has_name or has_type):
            print(f"  skipping {name} (not an item)")
            continue
        
        item_info = {}
        
        # WorkingNow 확인
        working_now_match = re.search(r'WorkingNow\s*=\s*true', item_data)
        is_working_now = working_now_match is not None
        if is_working_now:
            print(f"  WorkingNow detected - skipping XML generation for {name}")
            continue
        
        # extract id
        id_match = re.search(r'id\s*=\s*Isaac\.GetItemIdByName\("([^"]+)"\)', item_data)
        if id_match:
            item_info['id'] = id_match.group(1)
            print(f"  ID: {item_info['id']}")
        
        # extract name (multilingual structure)
        name_match = re.search(r'name\s*=\s*{', item_data)
        if name_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            name_start = name_match.end() - 1  # { 위치
            name_end = find_matching_brace(item_data, name_start)
            if name_end != -1:
                name_data = item_data[name_start+1:name_end]
                # 영어 이름 추출
                en_name_match = re.search(r'en\s*=\s*"([^"]+)"', name_data)
                if en_name_match:
                    item_info['name'] = en_name_match.group(1)
                    print(f"  Name (en): {item_info['name']}")
        else:
            # 단순 문자열 형태도 지원
            simple_name_match = re.search(r'name\s*=\s*"([^"]+)"', item_data)
            if simple_name_match:
                item_info['name'] = simple_name_match.group(1)
                print(f"  Name: {item_info['name']}")
        
        # extract type
        type_match = re.search(r'type\s*=\s*"([^"]+)"', item_data)
        if type_match:
            item_info['type'] = type_match.group(1)
            print(f"  Type: {item_info['type']}")
        
        # extract pool (array form)
        pool_match = re.search(r'pool\s*=\s*{', item_data)
        if pool_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            pool_start = pool_match.end() - 1  # { 위치
            pool_end = find_matching_brace(item_data, pool_start)
            if pool_end != -1:
                pool_data = item_data[pool_start+1:pool_end]
                item_info['pools'] = parse_pool_array(pool_data)
                print(f"  Pools: {item_info['pools']}")
        else:
            # support single pool form
            pool_match = re.search(r'pool\s*=\s*RoomType\.ROOM_(\w+)', item_data)
            if pool_match:
                item_info['pools'] = [pool_match.group(1)]
                print(f"  Pool: {item_info['pools']}")
        
        # extract weight
        weight_match = re.search(r'weight\s*=\s*([\d.]+)', item_data)
        if weight_match:
            item_info['weight'] = float(weight_match.group(1))
            print(f"  Weight: {item_info['weight']}")
        
        # extract DecreaseBy
        decrease_by_match = re.search(r'DecreaseBy\s*=\s*(\d+)', item_data)
        if decrease_by_match:
            item_info['DecreaseBy'] = int(decrease_by_match.group(1))
            print(f"  DecreaseBy: {item_info['DecreaseBy']}")
        
        # extract RemoveOn
        remove_on_match = re.search(r'RemoveOn\s*=\s*([\d.]+)', item_data)
        if remove_on_match:
            item_info['RemoveOn'] = float(remove_on_match.group(1))
            print(f"  RemoveOn: {item_info['RemoveOn']}")
        
        # extract quality
        quality_match = re.search(r'quality\s*=\s*(\d+)', item_data)
        if quality_match:
            item_info['quality'] = int(quality_match.group(1))
            print(f"  Quality: {item_info['quality']}")
        
        # extract tags
        tags_match = re.search(r'tags\s*=\s*"([^"]+)"', item_data)
        if tags_match:
            item_info['tags'] = tags_match.group(1)
            print(f"  Tags: {item_info['tags']}")
        
        # extract cache
        cache_match = re.search(r'cache\s*=\s*"([^"]+)"', item_data)
        if cache_match:
            item_info['cache'] = cache_match.group(1)
            print(f"  Cache: {item_info['cache']}")
        
        # extract hidden
        hidden_match = re.search(r'hidden\s*=\s*(true|false)', item_data)
        if hidden_match:
            item_info['hidden'] = hidden_match.group(1) == 'true'
            print(f"  Hidden: {item_info['hidden']}")
        
        # extract price (상점 가격)
        price_match = re.search(r'price\s*=\s*(\d+)', item_data)
        if price_match:
            item_info['price'] = int(price_match.group(1))
            print(f"  Price: {item_info['price']}")
        
        # extract devilprice (악마방 가격, 음수 값도 처리)
        devilprice_match = re.search(r'devilprice\s*=\s*(-?\d+)', item_data)
        if devilprice_match:
            item_info['devilprice'] = int(devilprice_match.group(1))
            print(f"  DevilPrice: {item_info['devilprice']}")
        
        # extract maxcharges
        maxcharges_match = re.search(r'maxcharges\s*=\s*(\d+)', item_data)
        if maxcharges_match:
            item_info['maxcharges'] = int(maxcharges_match.group(1))
            print(f"  MaxCharges: {item_info['maxcharges']}")
        
        # extract chargetype
        chargetype_match = re.search(r'chargetype\s*=\s*"([^"]+)"', item_data)
        if chargetype_match:
            item_info['chargetype'] = chargetype_match.group(1)
            print(f"  ChargeType: {item_info['chargetype']}")
        
        # extract initcharge
        initcharge_match = re.search(r'initcharge\s*=\s*(\d+)', item_data)
        if initcharge_match:
            item_info['initcharge'] = int(initcharge_match.group(1))
            print(f"  InitCharge: {item_info['initcharge']}")
        
        # extract hearts
        hearts_match = re.search(r'hearts\s*=\s*(-?\d+)', item_data)
        if hearts_match:
            item_info['hearts'] = int(hearts_match.group(1))
            print(f"  Hearts: {item_info['hearts']}")
        
        # extract maxhearts
        maxhearts_match = re.search(r'maxhearts\s*=\s*(-?\d+)', item_data)
        if maxhearts_match:
            item_info['maxhearts'] = int(maxhearts_match.group(1))
            print(f"  MaxHearts: {item_info['maxhearts']}")
        
        # extract blackhearts
        blackhearts_match = re.search(r'blackhearts\s*=\s*(\d+)', item_data)
        if blackhearts_match:
            item_info['blackhearts'] = int(blackhearts_match.group(1))
            print(f"  BlackHearts: {item_info['blackhearts']}")
        
        # extract soulhearts
        soulhearts_match = re.search(r'soulhearts\s*=\s*(\d+)', item_data)
        if soulhearts_match:
            item_info['soulhearts'] = int(soulhearts_match.group(1))
            print(f"  SoulHearts: {item_info['soulhearts']}")
        
        if item_info:
            items[name] = item_info
            print(f"  added item: {name}")
    
    return items

def create_items_xml(items, output_path):
    """create the items.xml file (mattpack format)"""
    root = ET.Element("items")
    root.set("gfxroot", "gfx/items/")
    root.set("version", "1")
    
    item_id_counter = 0
    
    for item_key, item_info in items.items():
        # determine the item type (use type if it exists, otherwise use maxcharges)
        item_type = item_info.get('type', 'passive')
        if not item_info.get('type') and item_info.get('maxcharges'):
            item_type = 'active'
        
        item_elem = ET.SubElement(root, item_type)
        
        item_elem.set("id", str(item_id_counter))
        item_elem.set("name", item_info.get('name', ''))
        item_elem.set("gfx", f"{item_key.lower()}.png")
        item_elem.set("quality", str(item_info.get('quality', 3)))
        item_elem.set("tags", item_info.get('tags', 'offensive'))
        
        # set additional attributes
        if item_info.get('cache'):
            item_elem.set("cache", item_info['cache'])
        
        if item_info.get('hidden'):
            item_elem.set("hidden", "true")
        
        if item_info.get('price'):
            item_elem.set("shopprice", str(item_info['price']))
        
        if item_info.get('devilprice'):
            item_elem.set("devilprice", str(item_info['devilprice']))
        
        if item_info.get('maxcharges'):
            item_elem.set("maxcharges", str(item_info['maxcharges']))
        
        if item_info.get('chargetype'):
            item_elem.set("chargetype", item_info['chargetype'])
        
        if item_info.get('initcharge'):
            item_elem.set("initcharge", str(item_info['initcharge']))
        
        if item_info.get('hearts'):
            item_elem.set("hearts", str(item_info['hearts']))
        
        if item_info.get('maxhearts'):
            item_elem.set("maxhearts", str(item_info['maxhearts']))
        
        if item_info.get('blackhearts'):
            item_elem.set("blackhearts", str(item_info['blackhearts']))
        
        if item_info.get('soulhearts'):
            item_elem.set("soulhearts", str(item_info['soulhearts']))
        
        item_id_counter += 1
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"items.xml created: {output_path}")

def create_itempools_xml(items, output_path):
    """create the itempools.xml file (mattpack format)"""
    root = ET.Element("ItemPools")
    
    # pool type mapping - 모든 RoomType 지원
    pool_mapping = {
        'ROOM_DEFAULT': 'default',
        'ROOM_SHOP': 'shop',
        'ROOM_TREASURE': 'treasure',
        'ROOM_BOSS': 'boss',
        'ROOM_MINIBOSS': 'miniboss',
        'ROOM_SECRET': 'secret',
        'ROOM_SUPERSECRET': 'ultraSecret',
        'ROOM_ARCADE': 'arcade',
        'ROOM_CURSE': 'curse',
        'ROOM_CHALLENGE': 'challenge',
        'ROOM_LIBRARY': 'library',
        'ROOM_SACRIFICE': 'sacrifice',
        'ROOM_DEVIL': 'devil',
        'ROOM_ANGEL': 'angel',
        'ROOM_DUNGEON': 'dungeon',
        'ROOM_BOSSRUSH': 'bossrush',
        'ROOM_ISAACS': 'isaacs',
        'ROOM_BARREN': 'barren',
        'ROOM_CHEST': 'chest',
        'ROOM_DICE': 'dice',
        'ROOM_BLACK_MARKET': 'blackMarket',
        'ROOM_GREED_EXIT': 'greedExit',
        'ROOM_PLANETARIUM': 'planetarium',
        'ROOM_TELEPORTER': 'teleporter',
        'ROOM_TELEPORTER_EXIT': 'teleporterExit',
        'ROOM_SECRET_EXIT': 'secretExit',
        'ROOM_BLUE': 'blue',
        'ROOM_ULTRASECRET': 'ultraSecret',
        # 기존 호환성을 위한 별칭
        'TREASURE': 'treasure',
        'SHOP': 'shop',
        'SECRET': 'secret',
        'SUPERSECRET': 'ultraSecret',
        'DEVIL': 'devil',
        'ANGEL': 'angel',
        'BOSS': 'boss',
        'MINIBOSS': 'miniboss'
    }
    
    # group items by pool
    pool_items = {}
    for item_key, item_info in items.items():
        pools = item_info.get('pools', ['ROOM_TREASURE'])
        
        for pool_entry in pools:
            # 풀 엔트리가 딕셔너리인지 단순 값인지 확인
            if isinstance(pool_entry, dict):
                # 딕셔너리 형태: {pool_type: True, weight=1.0, decrease_by=1, remove_on=0.1}
                pool_type = None
                weight = 1.0
                decrease_by = 1
                remove_on = 0.1
                
                for key, value in pool_entry.items():
                    if key == 'weight':
                        weight = value
                    elif key == 'decrease_by':
                        decrease_by = value
                    elif key == 'remove_on':
                        remove_on = value
                    elif key.startswith('ROOM_'):
                        # RoomType 값으로 간주
                        pool_type = key
                
                if pool_type:
                    pool_name = pool_mapping.get(str(pool_type), 'treasure')
                else:
                    continue
            else:
                # 단순 값: ROOM_XXX (기본값 사용)
                pool_name = pool_mapping.get(str(pool_entry), 'treasure')
                weight = 1.0
                decrease_by = 1
                remove_on = 0.1
            
            if pool_name not in pool_items:
                pool_items[pool_name] = []
            
            pool_items[pool_name].append({
                'name': item_info.get('name', item_key),  # name이 없으면 item_key 사용
                'weight': weight,
                'DecreaseBy': decrease_by,
                'RemoveOn': remove_on
            })
    
    # create each pool
    for pool_type, items_list in pool_items.items():
        pool_elem = ET.SubElement(root, "Pool")
        pool_elem.set("Name", pool_type)
        
        for item in items_list:
            item_elem = ET.SubElement(pool_elem, "Item")
            item_elem.set("Name", item['name'])
            item_elem.set("Weight", str(item['weight']))
            item_elem.set("DecreaseBy", str(item['DecreaseBy']))
            item_elem.set("RemoveOn", str(item['RemoveOn']))
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"itempools.xml created: {output_path}")

def main():
    """main function"""
    lua_file = "scripts/conch_blessing_items.lua"
    items_xml_path = "content/items.xml"
    itempools_xml_path = "content/itempools.xml"
    
    print("Conch's Blessing XML Generator started...")
    print(f"reading Lua file: {lua_file}")
    
    # parse the Lua file
    items = parse_lua_file(lua_file)
    
    if not items:
        print("warning: no items found.")
        return
    
    print(f"found items: {len(items)}")
    for name, info in items.items():
        print(f"  - {name}: {info.get('name', 'Unknown')} (ID: {info.get('id', 'Unknown')})")
    
    # create the XML files
    create_items_xml(items, items_xml_path)
    create_itempools_xml(items, itempools_xml_path)
    
    print("XML files created!")

if __name__ == "__main__":
    main() 