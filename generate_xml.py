#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conch's Blessing XML Generator
Auto generated by conch_blessing_items.lua
"""

import re
import os
import time
import xml.etree.ElementTree as ET
from xml.dom import minidom
import hashlib
try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    print("Warning: PIL (Pillow) not available. death_items.png generation will be skipped.")

def calculate_file_hash(file_path):
    """Calculate MD5 hash of a file"""
    if not os.path.exists(file_path):
        return None
    hash_md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def calculate_items_hash(items):
    """Calculate hash of items data for comparison"""
    # Create a string representation of items data
    items_str = ""
    for item_key in sorted(items.keys()):
        item_info = items[item_key]
        # Skip WorkingNow items for death_items generation
        if item_info.get('WorkingNow'):
            continue
        
        # Safely get name - handle both string and dict cases
        name = item_info.get('name', '')
        if isinstance(name, dict):
            name = name.get('en', '')
        elif not isinstance(name, str):
            name = str(name)
            
        items_str += f"{item_key}:{item_info.get('id', '')}:{name}\n"
    return hashlib.md5(items_str.encode()).hexdigest()

def find_matching_brace(content, start_pos):
    """detect the matching brace position"""
    brace_count = 0
    pos = start_pos
    
    while pos < len(content):
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
            if brace_count == 0:
                return pos
        pos += 1
    
    return -1

def parse_pool_array(pool_data):
    """parse the pool array with support for both simple and complex pool entries"""
    pools = []
    
    print(f"  Parsing pool data (full):")
    print(f"  '{pool_data}'")
    
    # 복잡한 풀 엔트리들을 먼저 찾아서 처리
    # {RoomType.ROOM_XXX, weight=1.0, decrease_by=1, remove_on=0.1} 형태
    # 여러 줄에 걸쳐 있을 수 있으므로 전체 텍스트에서 찾기
    complex_pattern = r'\{RoomType\.ROOM_(\w+),\s*weight=([\d.]+),\s*decrease_by=(\d+),\s*remove_on=([\d.]+)\}'
    complex_matches = re.findall(complex_pattern, pool_data, re.DOTALL)
    
    print(f"  Found {len(complex_matches)} complex matches: {complex_matches}")
    
    for match in complex_matches:
        room_type = match[0]
        weight = float(match[1])
        decrease_by = int(match[2])
        remove_on = float(match[3])
        
        pool_entry = f"ROOM_{room_type}"
        pool_dict = {pool_entry: True, 'weight': weight, 'decrease_by': decrease_by, 'remove_on': remove_on}
        pools.append(pool_dict)
        print(f"    Found complex pool: {pool_dict}")
    
    # 단순 풀 엔트리들 찾기 (복잡한 엔트리로 처리되지 않은 것들만)
    simple_matches = re.findall(r'RoomType\.ROOM_(\w+)', pool_data)
    for match in simple_matches:
        pool_entry = f"ROOM_{match}"
        # 이미 복잡한 엔트리로 처리되지 않은 경우만 추가
        if not any(isinstance(p, dict) and p.get(pool_entry) for p in pools):
            pools.append(pool_entry)
            print(f"    Added simple pool: {pool_entry}")
    
    print(f"  Final pools: {pools}")
    return pools

def parse_lua_file(file_path):
    """parse the lua file and extract the item information"""
    items = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: {file_path} file not found.")
        return items
    
    print(f"file length: {len(content)} characters")
    
    # remove comments (-- starting line)
    lines = []
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped.startswith('--'):
            lines.append(line)
    
    content = '\n'.join(lines)
    
    # find the ItemData table
    itemdata_pattern = r'ConchBlessing\.ItemData\s*=\s*{'
    itemdata_match = re.search(itemdata_pattern, content)
    
    if not itemdata_match:
        print("ItemData table not found.")
        print("file content:")
        print(content[:500])
        return items
    
    start_pos = itemdata_match.end() - 1  # { position
    end_pos = find_matching_brace(content, start_pos)
    
    if end_pos == -1:
        print("ItemData table end not found.")
        return items
    
    itemdata_content = content[start_pos+1:end_pos]
    print(f"ItemData content: {itemdata_content[:200]}...")
    
    # find the item pattern (LIVE_EYE = { ... })
    # 최상위 레벨의 아이템만 찾도록 수정
    item_pattern = r'(\w+)\s*=\s*{'
    item_matches = list(re.finditer(item_pattern, itemdata_content))
    
    print(f"found item matches: {len(item_matches)}")
    
    for match in item_matches:
        name = match.group(1)
        print(f"processing item: {name}")
        
        # find the item block start and end
        item_start = match.end() - 1  # { position
        item_end = find_matching_brace(itemdata_content, item_start)
        
        if item_end == -1:
            print(f"  warning: {name} item block end not found.")
            continue
        
        item_data = itemdata_content[item_start+1:item_end]
        print(f"  item data: {item_data[:100]}...")
        
        # 아이템이 아닌 중첩된 테이블인지 확인
        # id, name, type 중 하나라도 있으면 아이템으로 간주
        has_id = re.search(r'id\s*=', item_data)
        has_name = re.search(r'name\s*=', item_data)
        has_type = re.search(r'type\s*=', item_data)
        
        if not (has_id or has_name or has_type):
            print(f"  skipping {name} (not an item)")
            continue
        
        item_info = {}
        
        # WorkingNow 확인
        working_now_match = re.search(r'WorkingNow\s*=\s*true', item_data)
        is_working_now = working_now_match is not None
        if is_working_now:
            print(f"  WorkingNow detected - skipping XML generation for {name}")
            continue
        
        # extract id
        id_match = re.search(r'id\s*=\s*Isaac\.GetItemIdByName\("([^"]+)"\)', item_data)
        if id_match:
            item_info['id'] = id_match.group(1)
            print(f"  ID: {item_info['id']}")
        
        # extract name (multilingual structure)
        name_match = re.search(r'name\s*=\s*{', item_data)
        if name_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            name_start = name_match.end() - 1  # { 위치
            name_end = find_matching_brace(item_data, name_start)
            if name_end != -1:
                name_data = item_data[name_start+1:name_end]
                # 영어 이름 추출
                en_name_match = re.search(r'en\s*=\s*"([^"]+)"', name_data)
                if en_name_match:
                    item_info['name'] = en_name_match.group(1)
                    print(f"  Name (en): {item_info['name']}")
        else:
            # 단순 문자열 형태도 지원
            simple_name_match = re.search(r'name\s*=\s*"([^"]+)"', item_data)
            if simple_name_match:
                item_info['name'] = simple_name_match.group(1)
                print(f"  Name: {item_info['name']}")
        
        # extract type
        type_match = re.search(r'type\s*=\s*"([^"]+)"', item_data)
        if type_match:
            item_info['type'] = type_match.group(1)
            print(f"  Type: {item_info['type']}")
        
        # extract pool (array form)
        pool_match = re.search(r'pool\s*=\s*{', item_data)
        if pool_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            pool_start = pool_match.end() - 1  # { 위치
            pool_end = find_matching_brace(item_data, pool_start)
            if pool_end != -1:
                pool_data = item_data[pool_start+1:pool_end]
                item_info['pools'] = parse_pool_array(pool_data)
                print(f"  Pools: {item_info['pools']}")
        else:
            # support single pool form
            pool_match = re.search(r'pool\s*=\s*RoomType\.ROOM_(\w+)', item_data)
            if pool_match:
                item_info['pools'] = [pool_match.group(1)]
                print(f"  Pool: {item_info['pools']}")
        
        # extract weight
        weight_match = re.search(r'weight\s*=\s*([\d.]+)', item_data)
        if weight_match:
            item_info['weight'] = float(weight_match.group(1))
            print(f"  Weight: {item_info['weight']}")
        
        # extract DecreaseBy
        decrease_by_match = re.search(r'DecreaseBy\s*=\s*(\d+)', item_data)
        if decrease_by_match:
            item_info['DecreaseBy'] = int(decrease_by_match.group(1))
            print(f"  DecreaseBy: {item_info['DecreaseBy']}")
        
        # extract RemoveOn
        remove_on_match = re.search(r'RemoveOn\s*=\s*([\d.]+)', item_data)
        if remove_on_match:
            item_info['RemoveOn'] = float(remove_on_match.group(1))
            print(f"  RemoveOn: {item_info['RemoveOn']}")
        
        # extract quality
        quality_match = re.search(r'quality\s*=\s*(\d+)', item_data)
        if quality_match:
            item_info['quality'] = int(quality_match.group(1))
            print(f"  Quality: {item_info['quality']}")
        
        # extract tags
        tags_match = re.search(r'tags\s*=\s*"([^"]+)"', item_data)
        if tags_match:
            item_info['tags'] = tags_match.group(1)
            print(f"  Tags: {item_info['tags']}")
        
        # extract cache
        cache_match = re.search(r'cache\s*=\s*"([^"]+)"', item_data)
        if cache_match:
            item_info['cache'] = cache_match.group(1)
            print(f"  Cache: {item_info['cache']}")
        
        # extract hidden
        hidden_match = re.search(r'hidden\s*=\s*(true|false)', item_data)
        if hidden_match:
            item_info['hidden'] = hidden_match.group(1) == 'true'
            print(f"  Hidden: {item_info['hidden']}")
        
        # extract price (상점 가격)
        price_match = re.search(r'price\s*=\s*(\d+)', item_data)
        if price_match:
            item_info['price'] = int(price_match.group(1))
            print(f"  Price: {item_info['price']}")
        
        # extract devilprice (악마방 가격, 음수 값도 처리)
        devilprice_match = re.search(r'devilprice\s*=\s*(-?\d+)', item_data)
        if devilprice_match:
            item_info['devilprice'] = int(devilprice_match.group(1))
            print(f"  DevilPrice: {item_info['devilprice']}")
        
        # extract maxcharges
        maxcharges_match = re.search(r'maxcharges\s*=\s*(\d+)', item_data)
        if maxcharges_match:
            item_info['maxcharges'] = int(maxcharges_match.group(1))
            print(f"  MaxCharges: {item_info['maxcharges']}")
        
        # extract chargetype
        chargetype_match = re.search(r'chargetype\s*=\s*"([^"]+)"', item_data)
        if chargetype_match:
            item_info['chargetype'] = chargetype_match.group(1)
            print(f"  ChargeType: {item_info['chargetype']}")
        
        # extract initcharge
        initcharge_match = re.search(r'initcharge\s*=\s*(\d+)', item_data)
        if initcharge_match:
            item_info['initcharge'] = int(initcharge_match.group(1))
            print(f"  InitCharge: {item_info['initcharge']}")
        
        # extract hearts
        hearts_match = re.search(r'hearts\s*=\s*(-?\d+)', item_data)
        if hearts_match:
            item_info['hearts'] = int(hearts_match.group(1))
            print(f"  Hearts: {item_info['hearts']}")
        
        # extract maxhearts
        maxhearts_match = re.search(r'maxhearts\s*=\s*(-?\d+)', item_data)
        if maxhearts_match:
            item_info['maxhearts'] = int(maxhearts_match.group(1))
            print(f"  MaxHearts: {item_info['maxhearts']}")
        
        # extract blackhearts
        blackhearts_match = re.search(r'blackhearts\s*=\s*(\d+)', item_data)
        if blackhearts_match:
            item_info['blackhearts'] = int(blackhearts_match.group(1))
            print(f"  BlackHearts: {item_info['blackhearts']}")
        
        # extract soulhearts
        soulhearts_match = re.search(r'soulhearts\s*=\s*(\d+)', item_data)
        if soulhearts_match:
            item_info['soulhearts'] = int(soulhearts_match.group(1))
            print(f"  SoulHearts: {item_info['soulhearts']}")
        
        # extract custom ANM2 path (for familiars/entities)
        anm2_match = re.search(r'anm2\s*=\s*"([^"]+)"', item_data)
        if anm2_match:
            item_info['anm2'] = anm2_match.group(1)
            print(f"  ANM2: {item_info['anm2']}")

        # extract entity block
        entity_match = re.search(r'entity\s*=\s*{', item_data)
        if entity_match:
            ent_start = entity_match.end() - 1
            ent_end = find_matching_brace(item_data, ent_start)
            if ent_end != -1:
                ent_data = item_data[ent_start+1:ent_end]
                print(f"  Entity block found: {ent_data}")
                entity_info = {}
                # Map lower-case lua keys to XML attribute names
                key_map = {
                    'collisiondamage': 'collisionDamage',
                    'collisionmass': 'collisionMass',
                    'collisionradius': 'collisionRadius',
                    'friction': 'friction',
                    'numgridcollisionpoints': 'numGridCollisionPoints',
                    'shadowsize': 'shadowSize',
                    'tags': 'tags',
                    'customtags': 'customtags',
                    'anm2': 'anm2',
                    'variant': 'variant'
                }
                for kv in re.finditer(r'(\w+)\s*=\s*("[^"]*"|[-+]?[\d.]+)', ent_data):
                    k = kv.group(1).lower()
                    v = kv.group(2)
                    if v.startswith('"') and v.endswith('"'):
                        v = v[1:-1]
                    elif re.match(r'^-?[\d.]+$', v):
                        # keep numeric as is (stringify later)
                        pass
                    mapped = key_map.get(k)
                    if mapped:
                        entity_info[mapped] = v
                if entity_info:
                    item_info['entity'] = entity_info
                    print(f"  Parsed entity: {item_info['entity']}")

        # extract gibs block
        gibs_match = re.search(r'gibs\s*=\s*{', item_data)
        if gibs_match:
            gibs_start = gibs_match.end() - 1
            gibs_end = find_matching_brace(item_data, gibs_start)
            if gibs_end != -1:
                gibs_data = item_data[gibs_start+1:gibs_end]
                print(f"  Gibs block found: {gibs_data}")
                gibs_info = {}
                for kv in re.finditer(r'(amount|blood|bone|eye|gut|large)\s*=\s*(-?[\d.]+)', gibs_data, re.IGNORECASE):
                    k = kv.group(1).lower()
                    v = kv.group(2)
                    gibs_info[k] = v
                if gibs_info:
                    item_info['gibs'] = gibs_info
                    print(f"  Parsed gibs: {item_info['gibs']}")
        
        if item_info:
            items[name] = item_info
            print(f"  added item: {name}")
    
    return items

def create_entities2_xml(items, output_path):
    """create the entities2.xml file for familiars based on ItemData"""
    root = ET.Element("entities")
    root.set("anm2root", "gfx/")
    root.set("version", "5")

    for item_key, item_info in items.items():
        if str(item_info.get('type', '')).lower() != 'familiar':
            continue

        name = item_info.get('name', item_key)
        entity_elem = ET.SubElement(root, "entity")
        entity_elem.set("name", name)
        # Isaac familiar entity type is 3
        entity_elem.set("id", "3")
        
        # Resolve anm2path from entity block, top-level anm2, or fallback
        ent_meta = item_info.get('entity', {}) if isinstance(item_info.get('entity'), dict) else {}
        anm2_val = ent_meta.get('anm2') or item_info.get('anm2') or f"{item_key.lower()}.anm2"
        # Optional physical attributes
        def set_if_present(src_key, xml_key=None):
            if not xml_key:
                xml_key = src_key
            if src_key in ent_meta:
                entity_elem.set(xml_key, str(ent_meta[src_key]))
        
        set_if_present('variant')
        entity_elem.set("anm2path", str(anm2_val))
        set_if_present('collisionDamage')
        set_if_present('collisionMass')
        set_if_present('collisionRadius')
        set_if_present('friction')
        set_if_present('numGridCollisionPoints')
        set_if_present('shadowSize')
        set_if_present('tags')
        # customtags often desired (can be empty string)
        if 'customtags' in ent_meta:
            entity_elem.set('customtags', str(ent_meta['customtags']))
        else:
            # default to empty for consistency
            entity_elem.set('customtags', "")

        # Gibs child
        gibs_data = item_info.get('gibs', {}) if isinstance(item_info.get('gibs'), dict) else {}
        defaults = {'amount': '0', 'blood': '0', 'bone': '0', 'eye': '0', 'gut': '0', 'large': '0'}
        gibs_elem = ET.SubElement(entity_elem, "gibs")
        for k, default_val in defaults.items():
            gibs_elem.set(k, str(gibs_data.get(k, default_val)))

    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")

    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)

    print(f"entities2.xml created: {output_path}")

def create_items_xml(items, output_path):
    """create the items.xml file (mattpack format)"""
    root = ET.Element("items")
    root.set("gfxroot", "gfx/items/")
    root.set("deathanm2", "gfx/death_items.anm2")
    root.set("version", "1")
    
    item_id_counter = 0
    
    for item_key, item_info in items.items():
        # determine the item type (use type if it exists, otherwise use maxcharges)
        item_type = item_info.get('type', 'passive')
        if not item_info.get('type') and item_info.get('maxcharges'):
            item_type = 'active'

        # write exact type as tag, including <familiar> support
        item_elem = ET.SubElement(root, item_type)
        
        item_elem.set("id", str(item_id_counter))
        item_elem.set("name", item_info.get('name', ''))
        item_elem.set("gfx", f"{item_key.lower()}.png")
        # quality: exclude for trinkets (collectibles-like types include: passive, active, familiar)
        if item_type != 'trinket' and 'quality' in item_info:
            item_elem.set("quality", str(item_info.get('quality', 3)))
        # tags: remove entity-only tag 'cansacrifice' from items.xml
        tags_raw = item_info.get('tags')
        if tags_raw:
            tag_tokens = [t for t in str(tags_raw).split() if t != 'cansacrifice']
            if tag_tokens:
                item_elem.set("tags", " ".join(tag_tokens))
        
        # set additional attributes
        # cache: ensure familiars include "familiar" in cache flags
        cache_value = item_info.get('cache')
        if item_type == 'familiar':
            if cache_value:
                # append 'familiar' if not already present as a token
                tokens = set(str(cache_value).split())
                if 'familiar' not in tokens:
                    cache_value = str(cache_value) + ' familiars'
            else:
                cache_value = 'familiars'
        if cache_value:
            item_elem.set("cache", cache_value)
        
        if item_info.get('hidden'):
            item_elem.set("hidden", "true")
        
        if item_info.get('price'):
            item_elem.set("shopprice", str(item_info['price']))
        
        if item_info.get('devilprice'):
            item_elem.set("devilprice", str(item_info['devilprice']))
        
        if item_info.get('maxcharges'):
            item_elem.set("maxcharges", str(item_info['maxcharges']))
        
        if item_info.get('chargetype'):
            item_elem.set("chargetype", item_info['chargetype'])
        
        if item_info.get('initcharge') is not None:
            item_elem.set("initcharge", str(item_info['initcharge']))
        
        if item_info.get('hearts'):
            item_elem.set("hearts", str(item_info['hearts']))
        
        if item_info.get('maxhearts'):
            item_elem.set("maxhearts", str(item_info['maxhearts']))
        
        if item_info.get('blackhearts'):
            item_elem.set("blackhearts", str(item_info['blackhearts']))
        
        if item_info.get('soulhearts'):
            item_elem.set("soulhearts", str(item_info['soulhearts']))
        
        item_id_counter += 1
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"items.xml created: {output_path}")

def create_death_items_anm2(items, output_path):
    """create the death_items.anm2 file for death animation"""
    # WorkingNow가 아니고 trinket이 아닌 아이템만 필터링 (death items에는 trinket 제외)
    filtered_items = {
        k: v for k, v in items.items()
        if (not v.get('WorkingNow')) and (v.get('type') != 'trinket')
    }
    
    # 한 줄에 20개씩 배치
    items_per_row = 20
    frame_width = 16
    frame_height = 16
    
    # 아이템 개수 계산
    item_count = len(filtered_items)
    
    # 현재 아이템 데이터의 해시 계산
    current_hash = calculate_items_hash(items)
    
    # 기존 파일이 있고 해시가 같으면 스킵
    if os.path.exists(output_path):
        # 기존 파일의 마지막 수정 시간과 현재 아이템 해시를 비교
        # 간단한 방법으로 파일 크기와 아이템 개수로 비교
        try:
            with open(output_path, 'r', encoding='utf-8') as f:
                content = f.read()
                # 파일에 아이템 개수가 포함되어 있는지 확인
                if f'FrameNum="{item_count}"' in content:
                    print(f"death_items.anm2 unchanged, skipping: {output_path}")
                    return
        except:
            pass
    
    # XML 내용 생성
    xml_content = f'''<AnimatedActor>
	<Info CreatedBy="ConchBlessing XML Generator" CreatedOn="{time.strftime("%d.%m.%Y %H:%M:%S")}" Version="50" Fps="30"/>
	<Content>
		<Spritesheets>
			<Spritesheet Path="death_items.png" Id="0"/>
		</Spritesheets>
		<Layers>
			<Layer Name="Items" Id="0" SpritesheetId="0"/>
		</Layers>
		<Nulls/>
		<Events/>
	</Content>
	<Animations DefaultAnimation="icons">
		<Animation Name="icons" FrameNum="{item_count}" Loop="true">
			<RootAnimation>
				<Frame XPosition="0" YPosition="0" XScale="100" YScale="100" Delay="1" Visible="true" RedTint="255" GreenTint="255" BlueTint="255" AlphaTint="255" RedOffset="0" GreenOffset="0" BlueOffset="0" Rotation="0" Interpolated="false"/>
			</RootAnimation>
			<LayerAnimations>
				<LayerAnimation LayerId="0" Visible="true">'''
    
    # 각 아이템에 대한 프레임 생성
    for i in range(item_count):
        # 한 줄에 20개씩 배치
        row = i // items_per_row
        col = i % items_per_row
        
        # XCrop과 YCrop 계산
        x_crop = col * frame_width
        y_crop = row * frame_height
        
        xml_content += f'''
					<Frame XPosition="0" YPosition="0" XPivot="8" YPivot="8" XCrop="{x_crop}" YCrop="{y_crop}" Width="{frame_width}" Height="{frame_height}" XScale="100" YScale="100" Delay="1" Visible="true" RedTint="255" GreenTint="255" BlueTint="255" AlphaTint="255" RedOffset="0" GreenOffset="0" BlueOffset="0" Rotation="0" Interpolated="false"/>'''
    
    xml_content += '''
				</LayerAnimation>
			</LayerAnimations>
			<NullAnimations/>
			<Triggers/>
		</Animation>
	</Animations>
</AnimatedActor>'''
    
    # 파일 저장
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    
    print(f"death_items.anm2 created: {output_path}")

def create_itempools_xml(items, output_path):
    """create the itempools.xml file (mattpack format)"""
    root = ET.Element("ItemPools")
    
    # pool type mapping - 모든 RoomType 지원
    pool_mapping = {
        'ROOM_DEFAULT': 'default',
        'ROOM_SHOP': 'shop',
        'ROOM_TREASURE': 'treasure',
        'ROOM_BOSS': 'boss',
        'ROOM_MINIBOSS': 'miniboss',
        'ROOM_SECRET': 'secret',
        'ROOM_SUPERSECRET': 'ultraSecret',
        'ROOM_ARCADE': 'arcade',
        'ROOM_CURSE': 'curse',
        'ROOM_CHALLENGE': 'challenge',
        'ROOM_LIBRARY': 'library',
        'ROOM_SACRIFICE': 'sacrifice',
        'ROOM_DEVIL': 'devil',
        'ROOM_ANGEL': 'angel',
        'ROOM_DUNGEON': 'dungeon',
        'ROOM_BOSSRUSH': 'bossrush',
        'ROOM_ISAACS': 'isaacs',
        'ROOM_BARREN': 'barren',
        'ROOM_CHEST': 'chest',
        'ROOM_DICE': 'dice',
        'ROOM_BLACK_MARKET': 'blackMarket',
        'ROOM_GREED_EXIT': 'greedExit',
        'ROOM_PLANETARIUM': 'planetarium',
        'ROOM_TELEPORTER': 'teleporter',
        'ROOM_TELEPORTER_EXIT': 'teleporterExit',
        'ROOM_SECRET_EXIT': 'secretExit',
        'ROOM_BLUE': 'blue',
        'ROOM_ULTRASECRET': 'ultraSecret',
        # 기존 호환성을 위한 별칭
        'TREASURE': 'treasure',
        'SHOP': 'shop',
        'SECRET': 'secret',
        'SUPERSECRET': 'ultraSecret',
        'DEVIL': 'devil',
        'ANGEL': 'angel',
        'BOSS': 'boss',
        'MINIBOSS': 'miniboss'
    }
    
    # group items by pool (exclude trinkets)
    pool_items = {}
    debug_skipped_trinkets = 0
    for item_key, item_info in items.items():
        if str(item_info.get('type', '')).lower() == 'trinket':
            debug_skipped_trinkets += 1
            continue
        pools = item_info.get('pools', ['ROOM_TREASURE'])
        
        for pool_entry in pools:
            # 풀 엔트리가 딕셔너리인지 단순 값인지 확인
            if isinstance(pool_entry, dict):
                # 딕셔너리 형태: {pool_type: True, weight=1.0, decrease_by=1, remove_on=0.1}
                pool_type = None
                weight = 1.0
                decrease_by = 1
                remove_on = 0.1
                
                for key, value in pool_entry.items():
                    if key == 'weight':
                        weight = value
                    elif key == 'decrease_by':
                        decrease_by = value
                    elif key == 'remove_on':
                        remove_on = value
                    elif key.startswith('ROOM_'):
                        # RoomType 값으로 간주
                        pool_type = key
                
                if pool_type:
                    pool_name = pool_mapping.get(str(pool_type), 'treasure')
                else:
                    continue
            else:
                # 단순 값: ROOM_XXX (기본값 사용)
                pool_name = pool_mapping.get(str(pool_entry), 'treasure')
                weight = 1.0
                decrease_by = 1
                remove_on = 0.1
            
            if pool_name not in pool_items:
                pool_items[pool_name] = []
            
            pool_items[pool_name].append({
                'name': item_info.get('name', item_key),  # name이 없으면 item_key 사용
                'weight': weight,
                'DecreaseBy': decrease_by,
                'RemoveOn': remove_on
            })
    
    # create each pool
    for pool_type, items_list in pool_items.items():
        pool_elem = ET.SubElement(root, "Pool")
        pool_elem.set("Name", pool_type)
        
        for item in items_list:
            item_elem = ET.SubElement(pool_elem, "Item")
            item_elem.set("Name", item['name'])
            item_elem.set("Weight", str(item['weight']))
            item_elem.set("DecreaseBy", str(item['DecreaseBy']))
            item_elem.set("RemoveOn", str(item['RemoveOn']))
    
    # save the XML file
    xml_str = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
    
    # create the content directory
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(xml_str)
    
    print(f"itempools.xml created: {output_path} (skipped trinkets: {debug_skipped_trinkets})")

def generate_death_items_png(items, output_path):
    """Generate a single death_items.png by combining 16x16 images from the items directory."""
    if not PIL_AVAILABLE:
        print("PIL not available, skipping death_items.png generation.")
        return

    # WorkingNow가 아니고 trinket이 아닌 아이템만 필터링 (death items에는 trinket 제외)
    filtered_items = {
        k: v for k, v in items.items()
        if (not v.get('WorkingNow')) and (v.get('type') != 'trinket')
    }
    
    # 현재 아이템 데이터의 해시 계산
    current_hash = calculate_items_hash(items)
    
    # 기존 파일이 있고 해시가 같으면 스킵
    if os.path.exists(output_path):
        # 간단한 방법으로 파일 크기로 비교
        try:
            file_size = os.path.getsize(output_path)
            # 예상 파일 크기 계산 (대략적인 추정)
            expected_items = len(filtered_items)
            if expected_items > 0:
                items_per_row = 20
                rows_needed = (expected_items + items_per_row - 1) // items_per_row
                expected_width = min(items_per_row * 16, expected_items * 16)
                expected_height = rows_needed * 16
                expected_size = expected_width * expected_height * 4  # RGBA
                
                # 파일 크기가 비슷하면 스킵 (10% 오차 허용)
                if abs(file_size - expected_size) < expected_size * 0.1:
                    print(f"death_items.png unchanged, skipping: {output_path}")
                    return
        except:
            pass

    # 16x16 이미지를 저장할 딕셔너리
    images = {}
    for item_key, item_info in filtered_items.items():
            
        # 아이템 이미지 파일 경로: resources/gfx/items/collectibles/item_name.png
        item_gfx_path = os.path.join("resources/gfx/items/collectibles", f"{item_key.lower()}.png")
        
        if os.path.exists(item_gfx_path):
            try:
                img = Image.open(item_gfx_path)
                # 이미지를 16x16으로 리사이즈
                img = img.resize((16, 16), Image.Resampling.LANCZOS)
                images[item_key] = img
                print(f"  Loaded and resized image for {item_key}: {item_gfx_path}")
            except Exception as e:
                print(f"  Error loading or resizing image for {item_key}: {e}")
        else:
            print(f"  Warning: image not found for {item_key}: {item_gfx_path}")

    if not images:
        print("No valid images found to generate death_items.png.")
        return

    # 한 줄에 20개씩 배치하도록 계산
    items_per_row = 20
    frame_width = 16
    frame_height = 16
    
    # 총 아이템 개수
    total_items = len(images)
    
    # 필요한 행 수 계산
    rows_needed = (total_items + items_per_row - 1) // items_per_row
    
    # 최종 이미지 크기 계산 (320x640 또는 필요한 크기)
    final_width = min(items_per_row * frame_width, total_items * frame_width)
    final_height = rows_needed * frame_height
    
    # 투명 배경으로 새 이미지 생성
    new_image = Image.new('RGBA', (final_width, final_height), (0, 0, 0, 0))

    # 이미지들을 items.xml 순서대로 배치
    x_offset = 0
    y_offset = 0
    item_count = 0
    
    # items.xml에 나온 순서대로 정렬 (filtered_items 딕셔너리의 키 순서 유지)
    for item_key in filtered_items.keys():
        if item_key in images:  # WorkingNow가 아닌 아이템만
            img = images[item_key]
            
            # 현재 위치 계산
            current_row = item_count // items_per_row
            current_col = item_count % items_per_row
            
            x_pos = current_col * frame_width
            y_pos = current_row * frame_height
            
            # 이미지 붙이기
            new_image.paste(img, (x_pos, y_pos))
            item_count += 1
            
            print(f"  Placed {item_key} at position ({x_pos}, {y_pos})")

    # 파일 저장
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    new_image.save(output_path)
    print(f"death_items.png created: {output_path} with size {final_width}x{final_height}")
    print(f"Total items placed: {item_count}")

def main():
    """main function"""
    lua_file = "scripts/conch_blessing_items.lua"
    items_xml_path = "content/items.xml"
    itempools_xml_path = "content/itempools.xml"
    entities2_xml_path = "content/entities2.xml"
    death_items_anm2_path = "content/gfx/death_items.anm2"
    
    print("Conch's Blessing XML Generator started...")
    print(f"reading Lua file: {lua_file}")
    
    # parse the Lua file
    items = parse_lua_file(lua_file)
    
    if not items:
        print("warning: no items found.")
        return
    
    print(f"found items: {len(items)}")
    for name, info in items.items():
        print(f"  - {name}: {info.get('name', 'Unknown')} (ID: {info.get('id', 'Unknown')})")
    
    # create the XML files
    create_items_xml(items, items_xml_path)
    create_itempools_xml(items, itempools_xml_path)
    # Create entities2.xml for familiars/entities
    create_entities2_xml(items, entities2_xml_path)
    create_death_items_anm2(items, death_items_anm2_path)
    
    # Generate death_items.png from individual item images
    print("\nGenerating death_items.png...")
    generate_death_items_png(items, "content/gfx/death_items.png")
    
    print("\nAll files created successfully!")

if __name__ == "__main__":
    main() 