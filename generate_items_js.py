#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conch's Blessing Items.js Generator
Auto generated by conch_blessing_items.lua
"""

import re
import os
import json

def find_matching_brace(content, start_pos):
    """detect the matching brace position"""
    brace_count = 0
    pos = start_pos
    
    while pos < len(content):
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
            if brace_count == 0:
                return pos
        pos += 1
    
    return -1

def clean_eid_text(text):
    """clean EID text by removing {{}} templates and # symbols"""
    # {{Damage}} 같은 템플릿 문법 제거
    text = re.sub(r'\{\{[^}]+\}\}', '', text)
    # # 기호 제거
    text = text.replace('#', '')
    # 앞뒤 공백 제거
    text = text.strip()
    return text

def parse_pool_array(pool_data):
    """parse the pool array with support for both simple and complex pool entries"""
    pools = []
    
    print(f"  Parsing pool data (full):")
    print(f"  '{pool_data}'")
    
    # 복잡한 풀 엔트리들을 먼저 찾아서 처리
    # {RoomType.ROOM_XXX, weight=1.0, decrease_by=1, remove_on=0.1} 형태
    complex_pattern = r'\{RoomType\.ROOM_(\w+),\s*weight=([\d.]+),\s*decrease_by=(\d+),\s*remove_on=([\d.]+)\}'
    complex_matches = re.findall(complex_pattern, pool_data, re.DOTALL)
    
    print(f"  Found {len(complex_matches)} complex matches: {complex_matches}")
    
    for match in complex_matches:
        room_type = match[0]
        weight = float(match[1])
        decrease_by = int(match[2])
        remove_on = float(match[3])
        
        pool_entry = f"ROOM_{room_type}"
        pool_dict = {pool_entry: True, 'weight': weight, 'decrease_by': decrease_by, 'remove_on': remove_on}
        pools.append(pool_dict)
        print(f"    Found complex pool: {pool_dict}")
    
    # 단순 풀 엔트리들 찾기 (복잡한 엔트리로 처리되지 않은 것들만)
    simple_matches = re.findall(r'RoomType\.ROOM_(\w+)', pool_data)
    for match in simple_matches:
        pool_entry = f"ROOM_{match}"
        # 이미 복잡한 엔트리로 처리되지 않은 경우만 추가
        if not any(isinstance(p, dict) and p.get(pool_entry) for p in pools):
            pools.append(pool_entry)
            print(f"    Added simple pool: {pool_entry}")
    
    print(f"  Final pools: {pools}")
    return pools

def parse_lua_file(file_path):
    """parse the lua file and extract the item information"""
    items = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: {file_path} file not found.")
        return items
    
    print(f"file length: {len(content)} characters")
    
    # remove comments (-- starting line)
    lines = []
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped.startswith('--'):
            lines.append(line)
    
    content = '\n'.join(lines)
    
    # find the ItemData table
    itemdata_pattern = r'ConchBlessing\.ItemData\s*=\s*{'
    itemdata_match = re.search(itemdata_pattern, content)
    
    if not itemdata_match:
        print("ItemData table not found.")
        print("file content:")
        print(content[:500])
        return items
    
    start_pos = itemdata_match.end() - 1  # { position
    end_pos = find_matching_brace(content, start_pos)
    
    if end_pos == -1:
        print("ItemData table end not found.")
        return items
    
    itemdata_content = content[start_pos+1:end_pos]
    print(f"ItemData content: {itemdata_content[:200]}...")
    
    # find the item pattern (LIVE_EYE = { ... })
    # 최상위 레벨의 아이템만 찾도록 수정
    item_pattern = r'(\w+)\s*=\s*{'
    item_matches = list(re.finditer(item_pattern, itemdata_content))
    
    print(f"found item matches: {len(item_matches)}")
    
    for match in item_matches:
        name = match.group(1)
        print(f"processing item: {name}")
        
        # find the item block start and end
        item_start = match.end() - 1  # { position
        item_end = find_matching_brace(itemdata_content, item_start)
        
        if item_end == -1:
            print(f"  warning: {name} item block end not found.")
            continue
        
        item_data = itemdata_content[item_start+1:item_end]
        print(f"  item data: {item_data[:100]}...")
        
        # 아이템이 아닌 중첩된 테이블인지 확인
        # name, type 중 하나라도 있으면 아이템으로 간주
        has_name = re.search(r'name\s*=', item_data)
        has_type = re.search(r'type\s*=', item_data)
        
        if not (has_name or has_type):
            print(f"  skipping {name} (not an item)")
            continue
        
        item_info = {}
        
        # WORKING_NOW 확인
        working_now_match = re.search(r'WORKING_NOW\s*=\s*true', item_data)
        is_working_now = working_now_match is not None
        if is_working_now:
            print(f"  WORKING_NOW detected - treating as work-in-progress item")
        
        # extract name (multilingual structure)
        name_match = re.search(r'name\s*=\s*{', item_data)
        if name_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            name_start = name_match.end() - 1  # { 위치
            name_end = find_matching_brace(item_data, name_start)
            if name_end != -1:
                name_data = item_data[name_start+1:name_end]
                
                # 모든 언어의 이름을 자동으로 감지
                name_languages = {}
                for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', name_data):
                    lang = lang_match.group(1)
                    text = lang_match.group(2)
                    name_languages[lang] = text
                    print(f"  Name ({lang}): {text}")
                
                # 모든 언어 이름을 저장
                item_info['names'] = name_languages
        else:
            # 단순 문자열 형태도 지원
            simple_name_match = re.search(r'name\s*=\s*"([^"]+)"', item_data)
            if simple_name_match:
                # 단순 문자열도 names 형태로 변환
                item_info['names'] = {'en': simple_name_match.group(1)}
                print(f"  Name: {simple_name_match.group(1)}")
        
        # extract description (multilingual structure)
        desc_match = re.search(r'description\s*=\s*{', item_data)
        if desc_match:
            desc_start = desc_match.end() - 1
            desc_end = find_matching_brace(item_data, desc_start)
            if desc_end != -1:
                desc_data = item_data[desc_start+1:desc_end]
                # 모든 언어의 설명을 자동으로 감지
                desc_languages = {}
                for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', desc_data):
                    lang = lang_match.group(1)
                    text = lang_match.group(2)
                    desc_languages[lang] = text
                    print(f"  Description ({lang}): {text}")
                
                # 모든 언어 설명을 저장
                item_info['descriptions'] = desc_languages
        else:
            simple_desc_match = re.search(r'description\s*=\s*"([^"]+)"', item_data)
            if simple_desc_match:
                # 단순 문자열도 descriptions 형태로 변환
                item_info['descriptions'] = {'en': simple_desc_match.group(1)}
                print(f"  Description: {simple_desc_match.group(1)}")
        
        # extract EID (multilingual structure)
        eid_match = re.search(r'eid\s*=\s*{', item_data)
        if eid_match:
            eid_start = eid_match.end() - 1
            eid_end = find_matching_brace(item_data, eid_start)
            if eid_end != -1:
                eid_data = item_data[eid_start+1:eid_end]
                print(f"  EID data found: {eid_data[:200]}...")
                
                # 모든 언어의 EID 설명을 자동으로 감지
                eid_languages = {}
                
                # 각 언어 블록을 찾아서 처리
                for lang_match in re.finditer(r'(\w+)\s*=\s*{', eid_data):
                    lang = lang_match.group(1)
                    lang_start = lang_match.end() - 1
                    lang_end = find_matching_brace(eid_data, lang_start)
                    
                    if lang_end != -1:
                        lang_content = eid_data[lang_start+1:lang_end]
                        print(f"  {lang} EID content: {lang_content}")
                        
                        # 따옴표로 둘러싸인 텍스트들 추출하고 정리
                        eid_texts = re.findall(r'"([^"]+)"', lang_content)
                        # 각 텍스트에서 {{}} 템플릿과 # 기호 제거
                        cleaned_texts = [clean_eid_text(text) for text in eid_texts]
                        # 빈 문자열이 아닌 텍스트만 필터링
                        cleaned_texts = [text for text in cleaned_texts if text]
                        eid_languages[lang] = cleaned_texts
                        print(f"  Extracted {lang} EID texts: {cleaned_texts}")
                
                # 모든 언어 EID를 저장
                item_info['eids'] = eid_languages
                
                if not eid_languages:
                    print(f"  Warning: No EID descriptions found")
        
        # extract type
        type_match = re.search(r'type\s*=\s*"([^"]+)"', item_data)
        if type_match:
            item_info['type'] = type_match.group(1)
            print(f"  Type: {item_info['type']}")
        
        # extract pool (array form)
        pool_match = re.search(r'pool\s*=\s*{', item_data)
        if pool_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            pool_start = pool_match.end() - 1  # { 위치
            pool_end = find_matching_brace(item_data, pool_start)
            if pool_end != -1:
                pool_data = item_data[pool_start+1:pool_end]
                item_info['pools'] = parse_pool_array(pool_data)
                print(f"  Pools: {item_info['pools']}")
        else:
            # support single pool form
            pool_match = re.search(r'pool\s*=\s*RoomType\.ROOM_(\w+)', item_data)
            if pool_match:
                item_info['pools'] = [pool_match.group(1)]
                print(f"  Pool: {item_info['pools']}")
        
        # extract quality
        quality_match = re.search(r'quality\s*=\s*(\d+)', item_data)
        if quality_match:
            item_info['quality'] = int(quality_match.group(1))
            print(f"  Quality: {item_info['quality']}")
        
        # extract tags
        tags_match = re.search(r'tags\s*=\s*"([^"]+)"', item_data)
        if tags_match:
            item_info['tags'] = tags_match.group(1)
            print(f"  Tags: {item_info['tags']}")
        
        # extract cache
        cache_match = re.search(r'cache\s*=\s*"([^"]+)"', item_data)
        if cache_match:
            item_info['cache'] = cache_match.group(1)
            print(f"  Cache: {item_info['cache']}")
        
        # extract hidden
        hidden_match = re.search(r'hidden\s*=\s*(true|false)', item_data)
        if hidden_match:
            item_info['hidden'] = hidden_match.group(1) == 'true'
            print(f"  Hidden: {item_info['hidden']}")
        
        # extract shopprice
        shopprice_match = re.search(r'shopprice\s*=\s*(\d+)', item_data)
        if shopprice_match:
            item_info['shopprice'] = int(shopprice_match.group(1))
            print(f"  ShopPrice: {item_info['shopprice']}")
        
        # extract devilprice
        devilprice_match = re.search(r'devilprice\s*=\s*(-?\d+)', item_data)
        if devilprice_match:
            item_info['devilprice'] = int(devilprice_match.group(1))
            print(f"  DevilPrice: {item_info['devilprice']}")
        
        # extract maxcharges
        maxcharges_match = re.search(r'maxcharges\s*=\s*(\d+)', item_data)
        if maxcharges_match:
            item_info['maxcharges'] = int(maxcharges_match.group(1))
            print(f"  MaxCharges: {item_info['maxcharges']}")
        
        # extract chargetype
        chargetype_match = re.search(r'chargetype\s*=\s*"([^"]+)"', item_data)
        if chargetype_match:
            item_info['chargetype'] = chargetype_match.group(1)
            print(f"  ChargeType: {item_info['chargetype']}")
        
        # extract initcharge
        initcharge_match = re.search(r'initcharge\s*=\s*(\d+)', item_data)
        if initcharge_match:
            item_info['initcharge'] = int(initcharge_match.group(1))
            print(f"  InitCharge: {item_info['initcharge']}")
        
        # extract hearts
        hearts_match = re.search(r'hearts\s*=\s*(-?\d+)', item_data)
        if hearts_match:
            item_info['hearts'] = int(hearts_match.group(1))
            print(f"  Hearts: {item_info['hearts']}")
        
        # extract maxhearts
        maxhearts_match = re.search(r'maxhearts\s*=\s*(-?\d+)', item_data)
        if maxhearts_match:
            item_info['maxhearts'] = int(maxhearts_match.group(1))
            print(f"  MaxHearts: {item_info['maxhearts']}")
        
        # extract blackhearts
        blackhearts_match = re.search(r'blackhearts\s*=\s*(\d+)', item_data)
        if blackhearts_match:
            item_info['blackhearts'] = int(blackhearts_match.group(1))
            print(f"  BlackHearts: {item_info['blackhearts']}")
        
        # extract soulhearts
        soulhearts_match = re.search(r'soulhearts\s*=\s*(\d+)', item_data)
        if soulhearts_match:
            item_info['soulhearts'] = int(soulhearts_match.group(1))
            print(f"  SoulHearts: {item_info['soulhearts']}")
        
        # extract origin
        origin_match = re.search(r'origin\s*=\s*CollectibleType\.COLLECTIBLE_(\w+)', item_data)
        if origin_match:
            item_info['origin'] = origin_match.group(1)
            print(f"  Origin: {item_info['origin']}")
        
        # extract flag
        flag_match = re.search(r'flag\s*=\s*"([^"]+)"', item_data)
        if flag_match:
            item_info['flag'] = flag_match.group(1)
            print(f"  Flag: {item_info['flag']}")
        
        if item_info:
            if is_working_now:
                # WORKING_NOW 아이템은 names, descriptions, eids만 남기고 나머지 제거
                working_item_info = {
                    'names': item_info.get('names', {}),
                    'descriptions': {
                        'kr': '작업중인 아이템입니다',
                        'en': 'Work in progress item'
                    },
                    'eids': {
                        'kr': ['작업중인 아이템입니다'],
                        'en': ['Work in progress item']
                    }
                }
                
                items[name] = working_item_info
                print(f"  added work-in-progress item: {name} (names, descriptions, eids only)")
            else:
                items[name] = item_info
                print(f"  added item: {name}")
    
    return items

def create_items_js(items, output_path):
    """create the items.js file for documentation"""
    
    js_content = """// Conch's Blessing Items Data
// Auto-generated from conch_blessing_items.lua

const items = {
"""
    
    for item_key, item_info in items.items():
        # WORKING_NOW 아이템인지 확인
        is_working_now = len(item_info) == 3 and 'names' in item_info and 'descriptions' in item_info and 'eids' in item_info
        
        if is_working_now:
            # WORKING_NOW 아이템은 names, descriptions, eids, gfx만 출력
            js_content += f"""    {item_key}: {{
        gfx: "resources/gfx/items/collectibles/{item_key.lower()}.png",
        names: {json.dumps(item_info['names'], ensure_ascii=False)},
        descriptions: {json.dumps(item_info['descriptions'], ensure_ascii=False)},
        eids: {json.dumps(item_info['eids'], ensure_ascii=False)}"""
        else:
            # 일반 아이템은 모든 필드 출력
            js_content += f"""    {item_key}: {{
        type: "{item_info.get('type', 'passive')}",
        gfx: "resources/gfx/items/collectibles/{item_key.lower()}.png",
        quality: {item_info.get('quality', 3)},
        tags: "{item_info.get('tags', '')}",
        cache: "{item_info.get('cache', '')}",
        hidden: {str(item_info.get('hidden', False)).lower()},
        shopprice: {item_info.get('shopprice', 0)},
        devilprice: {item_info.get('devilprice', 0)},
        maxcharges: {item_info.get('maxcharges', 0)},
        chargetype: "{item_info.get('chargetype', 'normal')}",
        initcharge: {item_info.get('initcharge', 0)},
        hearts: {item_info.get('hearts', 0)},
        maxhearts: {item_info.get('maxhearts', 0)},
        blackhearts: {item_info.get('blackhearts', 0)},
        soulhearts: {item_info.get('soulhearts', 0)},
        origin: "{item_info.get('origin', '')}",
        flag: "{item_info.get('flag', '')}",
        pools: {json.dumps(item_info.get('pools', []))}"""
            
            # 일반 아이템에만 다국어 정보 추가
            if 'names' in item_info:
                js_content += f""",
        names: {json.dumps(item_info['names'], ensure_ascii=False)}"""
            
            if 'descriptions' in item_info:
                js_content += f""",
        descriptions: {json.dumps(item_info['descriptions'], ensure_ascii=False)}"""
            
            if 'eids' in item_info:
                js_content += f""",
        eids: {json.dumps(item_info['eids'], ensure_ascii=False)}"""
        
        js_content += """
    },
"""
    
    js_content += """};

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = items;
}

// Make available globally for browser
if (typeof window !== 'undefined') {
    window.items = items;
}
"""
    
    # 파일이 프로젝트 루트에 생성되므로 디렉토리 생성 불필요
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(js_content)
    
    print(f"items.js created: {output_path}")

def main():
    """main function"""
    lua_file = "scripts/conch_blessing_items.lua"
    items_js_path = "items.js"  # 프로젝트 루트에 생성
    
    print("Conch's Blessing Items.js Generator started...")
    print(f"reading Lua file: {lua_file}")
    
    # parse the Lua file
    items = parse_lua_file(lua_file)
    
    if not items:
        print("warning: no items found.")
        return
    
    print(f"found items: {len(items)}")
    for name, info in items.items():
        print(f"  - {name}: {info.get('name', 'Unknown')} (ID: {info.get('id', 'Unknown')})")
    
    # create the items.js file
    create_items_js(items, items_js_path)
    
    print("items.js file created!")

if __name__ == "__main__":
    main() 