#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Conch's Blessing Items.js Generator
Auto generated by conch_blessing_items.lua
"""

import re
import os
import json

def find_matching_brace(content, start_pos):
    """detect the matching brace position"""
    brace_count = 0
    pos = start_pos
    
    while pos < len(content):
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
            if brace_count == 0:
                return pos
        pos += 1
    
    return -1

def clean_eid_text(text):
    """clean EID text by removing {{}} templates and # symbols"""
    # {{Damage}} 같은 템플릿 문법 제거
    text = re.sub(r'\{\{[^}]+\}\}', '', text)
    # # 기호 제거
    text = text.replace('#', '')
    # 앞뒤 공백 제거
    text = text.strip()
    return text

def parse_pool_array(pool_data):
    """parse the pool array with support for both simple and complex pool entries"""
    pools = []
    
    print(f"  Parsing pool data (full):")
    print(f"  '{pool_data}'")
    
    # 복잡한 풀 엔트리들을 먼저 찾아서 처리
    # {RoomType.ROOM_XXX, weight=1.0, decrease_by=1, remove_on=0.1} 형태
    complex_pattern = r'\{RoomType\.ROOM_(\w+),\s*weight=([\d.]+),\s*decrease_by=(\d+),\s*remove_on=([\d.]+)\}'
    complex_matches = re.findall(complex_pattern, pool_data, re.DOTALL)
    
    print(f"  Found {len(complex_matches)} complex matches: {complex_matches}")
    
    for match in complex_matches:
        room_type = match[0]
        weight = float(match[1])
        decrease_by = int(match[2])
        remove_on = float(match[3])
        
        pool_entry = f"ROOM_{room_type}"
        pool_dict = {pool_entry: True, 'weight': weight, 'decrease_by': decrease_by, 'remove_on': remove_on}
        pools.append(pool_dict)
        print(f"    Found complex pool: {pool_dict}")
    
    # 단순 풀 엔트리들 찾기 (복잡한 엔트리로 처리되지 않은 것들만)
    simple_matches = re.findall(r'RoomType\.ROOM_(\w+)', pool_data)
    for match in simple_matches:
        pool_entry = f"ROOM_{match}"
        # 이미 복잡한 엔트리로 처리되지 않은 경우만 추가
        if not any(isinstance(p, dict) and p.get(pool_entry) for p in pools):
            pools.append(pool_entry)
            print(f"    Added simple pool: {pool_entry}")
    
    print(f"  Final pools: {pools}")
    return pools

def parse_lua_file(file_path):
    """parse the lua file and extract the item information"""
    items = {}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: {file_path} file not found.")
        return items
    
    print(f"file length: {len(content)} characters")
    
    # remove comments (-- starting line)
    lines = []
    for line in content.split('\n'):
        stripped = line.strip()
        if not stripped.startswith('--'):
            lines.append(line)
    
    content = '\n'.join(lines)
    
    # find the ItemData table
    itemdata_pattern = r'ConchBlessing\.ItemData\s*=\s*{'
    itemdata_match = re.search(itemdata_pattern, content)
    
    if not itemdata_match:
        print("ItemData table not found.")
        print("file content:")
        print(content[:500])
        return items
    
    start_pos = itemdata_match.end() - 1  # { position
    end_pos = find_matching_brace(content, start_pos)
    
    if end_pos == -1:
        print("ItemData table end not found.")
        return items
    
    itemdata_content = content[start_pos+1:end_pos]
    print(f"ItemData content: {itemdata_content[:200]}...")
    
    # find the item pattern (LIVE_EYE = { ... })
    # 최상위 레벨의 아이템만 찾도록 수정
    item_pattern = r'(\w+)\s*=\s*{'
    item_matches = list(re.finditer(item_pattern, itemdata_content))
    
    print(f"found item matches: {len(item_matches)}")
    
    for match in item_matches:
        name = match.group(1)
        print(f"processing item: {name}")
        
        # find the item block start and end
        item_start = match.end() - 1  # { position
        item_end = find_matching_brace(itemdata_content, item_start)
        
        if item_end == -1:
            print(f"  warning: {name} item block end not found.")
            continue
        
        item_data = itemdata_content[item_start+1:item_end]
        print(f"  item data: {item_data[:100]}...")
        
        # 아이템이 아닌 중첩된 테이블인지 확인
        # name, type 중 하나라도 있으면 아이템으로 간주
        has_name = re.search(r'name\s*=', item_data)
        has_type = re.search(r'type\s*=', item_data)
        
        # 특정 키워드로 시작하는 것은 건너뛰기
        skip_keywords = ['synergies', 'callbacks', 'onBeforeChange', 'onAfterChange']
        if name in skip_keywords:
            print(f"  skipping {name} (reserved keyword)")
            continue
        
        if not (has_name or has_type):
            print(f"  skipping {name} (not an item)")
            continue
        
        item_info = {}
        
        # WorkingNow 확인
        working_now_match = re.search(r'WorkingNow\s*=\s*true', item_data)
        is_working_now = working_now_match is not None
        if is_working_now:
            print(f"  WorkingNow detected - treating as work-in-progress item")
        
        # extract name (multilingual structure)
        name_match = re.search(r'name\s*=\s*{', item_data)
        if name_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            name_start = name_match.end() - 1  # { 위치
            name_end = find_matching_brace(item_data, name_start)
            if name_end != -1:
                name_data = item_data[name_start+1:name_end]
                
                # 모든 언어의 이름을 자동으로 감지
                name_languages = {}
                for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', name_data):
                    lang = lang_match.group(1)
                    text = lang_match.group(2)
                    name_languages[lang] = text
                    print(f"  Name ({lang}): {text}")
                
                # 모든 언어 이름을 저장
                item_info['names'] = name_languages
        else:
            # 단순 문자열 형태도 지원
            simple_name_match = re.search(r'name\s*=\s*"([^"]+)"', item_data)
            if simple_name_match:
                # 단순 문자열도 names 형태로 변환
                item_info['names'] = {'en': simple_name_match.group(1)}
                print(f"  Name: {simple_name_match.group(1)}")
        
        # extract description (multilingual structure)
        desc_match = re.search(r'description\s*=\s*{', item_data)
        if desc_match:
            desc_start = desc_match.end() - 1
            desc_end = find_matching_brace(item_data, desc_start)
            if desc_end != -1:
                desc_data = item_data[desc_start+1:desc_end]
                # 모든 언어의 설명을 자동으로 감지
                desc_languages = {}
                for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', desc_data):
                    lang = lang_match.group(1)
                    text = lang_match.group(2)
                    desc_languages[lang] = text
                    print(f"  Description ({lang}): {text}")
                
                # 모든 언어 설명을 저장
                item_info['descriptions'] = desc_languages
        else:
            simple_desc_match = re.search(r'description\s*=\s*"([^"]+)"', item_data)
            if simple_desc_match:
                # 단순 문자열도 descriptions 형태로 변환
                item_info['descriptions'] = {'en': simple_desc_match.group(1)}
                print(f"  Description: {simple_desc_match.group(1)}")
        
        # extract EID (multilingual structure)
        eid_match = re.search(r'eid\s*=\s*{', item_data)
        if eid_match:
            eid_start = eid_match.end() - 1
            eid_end = find_matching_brace(item_data, eid_start)
            if eid_end != -1:
                eid_data = item_data[eid_start+1:eid_end]
                print(f"  EID data found: {eid_data[:200]}...")
                
                # 모든 언어의 EID 설명을 자동으로 감지
                eid_languages = {}
                
                # 각 언어 블록을 찾아서 처리
                for lang_match in re.finditer(r'(\w+)\s*=\s*{', eid_data):
                    lang = lang_match.group(1)
                    lang_start = lang_match.end() - 1
                    lang_end = find_matching_brace(eid_data, lang_start)
                    
                    if lang_end != -1:
                        lang_content = eid_data[lang_start+1:lang_end]
                        print(f"  {lang} EID content: {lang_content}")
                        
                        # 따옴표로 둘러싸인 텍스트들 추출하고 정리
                        eid_texts = re.findall(r'"([^"]+)"', lang_content)
                        # 각 텍스트에서 {{}} 템플릿과 # 기호 제거
                        cleaned_texts = [clean_eid_text(text) for text in eid_texts]
                        # 빈 문자열이 아닌 텍스트만 필터링
                        cleaned_texts = [text for text in cleaned_texts if text]
                        eid_languages[lang] = cleaned_texts
                        print(f"  Extracted {lang} EID texts: {cleaned_texts}")
                
                # 모든 언어 EID를 저장
                item_info['eids'] = eid_languages
                
                if not eid_languages:
                    print(f"  Warning: No EID descriptions found")
        
        # extract type
        type_match = re.search(r'type\s*=\s*"([^"]+)"', item_data)
        if type_match:
            item_info['type'] = type_match.group(1)
            print(f"  Type: {item_info['type']}")
        
        # extract pool (array form)
        pool_match = re.search(r'pool\s*=\s*{', item_data)
        if pool_match:
            # 중첩된 중괄호를 올바르게 처리하기 위해 find_matching_brace 사용
            pool_start = pool_match.end() - 1  # { 위치
            pool_end = find_matching_brace(item_data, pool_start)
            if pool_end != -1:
                pool_data = item_data[pool_start+1:pool_end]
                item_info['pools'] = parse_pool_array(pool_data)
                print(f"  Pools: {item_info['pools']}")
        else:
            # support single pool form
            pool_match = re.search(r'pool\s*=\s*RoomType\.ROOM_(\w+)', item_data)
            if pool_match:
                item_info['pools'] = [pool_match.group(1)]
                print(f"  Pool: {item_info['pools']}")
        
        # extract quality
        quality_match = re.search(r'quality\s*=\s*(\d+)', item_data)
        if quality_match:
            item_info['quality'] = int(quality_match.group(1))
            print(f"  Quality: {item_info['quality']}")
        
        # extract tags
        tags_match = re.search(r'tags\s*=\s*"([^"]+)"', item_data)
        if tags_match:
            item_info['tags'] = tags_match.group(1)
            print(f"  Tags: {item_info['tags']}")
        
        # extract cache
        cache_match = re.search(r'cache\s*=\s*"([^"]+)"', item_data)
        if cache_match:
            item_info['cache'] = cache_match.group(1)
            print(f"  Cache: {item_info['cache']}")
        
        # extract hidden
        hidden_match = re.search(r'hidden\s*=\s*(true|false)', item_data)
        if hidden_match:
            item_info['hidden'] = hidden_match.group(1) == 'true'
            print(f"  Hidden: {item_info['hidden']}")
        
        # extract shopprice
        shopprice_match = re.search(r'shopprice\s*=\s*(\d+)', item_data)
        if shopprice_match:
            item_info['shopprice'] = int(shopprice_match.group(1))
            print(f"  ShopPrice: {item_info['shopprice']}")
        
        # extract devilprice
        devilprice_match = re.search(r'devilprice\s*=\s*(-?\d+)', item_data)
        if devilprice_match:
            item_info['devilprice'] = int(devilprice_match.group(1))
            print(f"  DevilPrice: {item_info['devilprice']}")
        
        # extract maxcharges
        maxcharges_match = re.search(r'maxcharges\s*=\s*(\d+)', item_data)
        if maxcharges_match:
            item_info['maxcharges'] = int(maxcharges_match.group(1))
            print(f"  MaxCharges: {item_info['maxcharges']}")
        
        # extract chargetype
        chargetype_match = re.search(r'chargetype\s*=\s*"([^"]+)"', item_data)
        if chargetype_match:
            item_info['chargetype'] = chargetype_match.group(1)
            print(f"  ChargeType: {item_info['chargetype']}")
        
        # extract initcharge
        initcharge_match = re.search(r'initcharge\s*=\s*(\d+)', item_data)
        if initcharge_match:
            item_info['initcharge'] = int(initcharge_match.group(1))
            print(f"  InitCharge: {item_info['initcharge']}")
        
        # extract hearts
        hearts_match = re.search(r'hearts\s*=\s*(-?\d+)', item_data)
        if hearts_match:
            item_info['hearts'] = int(hearts_match.group(1))
            print(f"  Hearts: {item_info['hearts']}")
        
        # extract maxhearts
        maxhearts_match = re.search(r'maxhearts\s*=\s*(-?\d+)', item_data)
        if maxhearts_match:
            item_info['maxhearts'] = int(maxhearts_match.group(1))
            print(f"  MaxHearts: {item_info['maxhearts']}")
        
        # extract blackhearts
        blackhearts_match = re.search(r'blackhearts\s*=\s*(\d+)', item_data)
        if blackhearts_match:
            item_info['blackhearts'] = int(blackhearts_match.group(1))
            print(f"  BlackHearts: {item_info['blackhearts']}")
        
        # extract soulhearts
        soulhearts_match = re.search(r'soulhearts\s*=\s*(\d+)', item_data)
        if soulhearts_match:
            item_info['soulhearts'] = int(soulhearts_match.group(1))
            print(f"  SoulHearts: {item_info['soulhearts']}")

        # extract entity block (for docs)
        entity_match = re.search(r'entity\s*=\s*{', item_data)
        if entity_match:
            ent_start = entity_match.end() - 1
            ent_end = find_matching_brace(item_data, ent_start)
            if ent_end != -1:
                ent_data = item_data[ent_start+1:ent_end]
                print(f"  Entity block found: {ent_data}")
                entity_info = {}
                for kv in re.finditer(r'(\w+)\s*=\s*("[^"]*"|[-+]?[\d.]+)', ent_data):
                    k = kv.group(1)
                    v = kv.group(2)
                    if v.startswith('"') and v.endswith('"'):
                        v = v[1:-1]
                    entity_info[k] = v
                if entity_info:
                    item_info['entity'] = entity_info
                    print(f"  Parsed entity: {item_info['entity']}")

        # extract gibs block (for docs)
        gibs_match = re.search(r'gibs\s*=\s*{', item_data)
        if gibs_match:
            gibs_start = gibs_match.end() - 1
            gibs_end = find_matching_brace(item_data, gibs_start)
            if gibs_end != -1:
                gibs_data = item_data[gibs_start+1:gibs_end]
                print(f"  Gibs block found: {gibs_data}")
                gibs_info = {}
                for kv in re.finditer(r'(amount|blood|bone|eye|gut|large)\s*=\s*(-?[\d.]+)', gibs_data, re.IGNORECASE):
                    k = kv.group(1)
                    v = kv.group(2)
                    gibs_info[k] = v
                if gibs_info:
                    item_info['gibs'] = gibs_info
                    print(f"  Parsed gibs: {item_info['gibs']}")
        
        # extract origin (Collectible, Trinket, Card, Pill)
        origin_match_coll = re.search(r'origin\s*=\s*CollectibleType\.COLLECTIBLE_(\w+)', item_data)
        origin_match_trinket = re.search(r'origin\s*=\s*TrinketType\.TRINKET_(\w+)', item_data)
        origin_match_card = re.search(r'origin\s*=\s*Card\.CARD_(\w+)', item_data)
        origin_match_pill = re.search(r'origin\s*=\s*PillEffect\.PILLEFFECT_(\w+)', item_data)
        if origin_match_trinket:
            item_info['origin'] = origin_match_trinket.group(1)
            item_info['originType'] = 'trinket'
            print(f"  Origin (Trinket): {item_info['origin']}")
        elif origin_match_coll:
            item_info['origin'] = origin_match_coll.group(1)
            item_info['originType'] = 'collectible'
            print(f"  Origin (Collectible): {item_info['origin']}")
        elif origin_match_card:
            item_info['origin'] = origin_match_card.group(1)
            item_info['originType'] = 'card'
            print(f"  Origin (Card): {item_info['origin']}")
        elif origin_match_pill:
            item_info['origin'] = origin_match_pill.group(1)
            item_info['originType'] = 'pill'
            print(f"  Origin (Pill): {item_info['origin']}")
        
        # extract flag
        flag_match = re.search(r'flag\s*=\s*"([^"]+)"', item_data)
        if flag_match:
            item_info['flag'] = flag_match.group(1)
            print(f"  Flag: {item_info['flag']}")
        
        # extract synergies
        synergies_match = re.search(r'synergies\s*=\s*{', item_data)
        print(f"  Looking for synergies in {name}: {'Found' if synergies_match else 'Not found'}")
        if synergies_match:
            synergies_start = synergies_match.end() - 1
            synergies_end = find_matching_brace(item_data, synergies_start)
            if synergies_end != -1:
                synergies_data = item_data[synergies_start+1:synergies_end]
                print(f"  Synergies data found: {synergies_data[:200]}...")
                print(f"  Full synergies data: {synergies_data}")
                
                synergies = {}
                synergy_types = {}
                # [CollectibleType.COLLECTIBLE_XXX] and [TrinketType.TRINKET_XXX] blocks
                synergy_pattern_coll = r'\[CollectibleType\.COLLECTIBLE_(\w+)\]\s*=\s*{'
                synergy_pattern_trinket = r'\[TrinketType\.TRINKET_(\w+)\]\s*=\s*{'
                synergy_matches = list(re.finditer(synergy_pattern_coll, synergies_data))
                synergy_matches_tr = list(re.finditer(synergy_pattern_trinket, synergies_data))
                
                print(f"    Synergy pattern (collectible): {synergy_pattern_coll}")
                print(f"    Synergy pattern (trinket): {synergy_pattern_trinket}")
                print(f"    Synergies data to search: {synergies_data}")
                
                for match in synergy_matches:
                    synergy_item = match.group(1)
                    print(f"    Found synergy collectible: {synergy_item}")
                    block_start = match.end() - 1
                    block_end = find_matching_brace(synergies_data, block_start)
                    if block_end != -1:
                        block_content = synergies_data[block_start+1:block_end]
                        print(f"    Block content: {block_content}")
                        synergy_desc = {}
                        for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', block_content):
                            lang = lang_match.group(1)
                            text = lang_match.group(2)
                            synergy_desc[lang] = text
                            print(f"    Synergy {synergy_item} ({lang}): {text}")
                        synergies[synergy_item] = synergy_desc
                        synergy_types[synergy_item] = 'collectible'
                    else:
                        print(f"    Failed to find block end for {synergy_item}")

                for match in synergy_matches_tr:
                    synergy_item = match.group(1)
                    print(f"    Found synergy trinket: {synergy_item}")
                    block_start = match.end() - 1
                    block_end = find_matching_brace(synergies_data, block_start)
                    if block_end != -1:
                        block_content = synergies_data[block_start+1:block_end]
                        print(f"    Block content: {block_content}")
                        synergy_desc = {}
                        for lang_match in re.finditer(r'(\w+)\s*=\s*"([^"]+)"', block_content):
                            lang = lang_match.group(1)
                            text = lang_match.group(2)
                            synergy_desc[lang] = text
                            print(f"    Synergy {synergy_item} ({lang}): {text}")
                        synergies[synergy_item] = synergy_desc
                        synergy_types[synergy_item] = 'trinket'
                    else:
                        print(f"    Failed to find block end for {synergy_item}")
                
                print(f"    Final synergies dict: {synergies}")
                if synergies:
                    item_info['synergies'] = synergies
                    if synergy_types:
                        item_info['synergy_types'] = synergy_types
                    print(f"  Synergies: {list(synergies.keys())}")
                else:
                    print(f"  No synergies extracted from data")
        
        if item_info:
            if is_working_now:
                # WorkingNow 아이템은 names, descriptions, eids만 남기고 나머지 제거
                working_item_info = {
                    'names': item_info.get('names', {}),
                    'descriptions': {
                        'kr': '작업중인 아이템입니다',
                        'en': 'Work in progress item'
                    },
                    'eids': {
                        'kr': ['작업중인 아이템입니다'],
                        'en': ['Work in progress item']
                    }
                }
                
                items[name] = working_item_info
                print(f"  added work-in-progress item: {name} (names, descriptions, eids only)")
            else:
                items[name] = item_info
                print(f"  added item: {name}")
    
    return items

def create_items_js(items, output_path):
    """create the items.js file for documentation"""
    
    js_content = """// Conch's Blessing Items Data
// Auto-generated from conch_blessing_items.lua

const items = {
"""
    
    for item_key, item_info in items.items():
        # WorkingNow 아이템인지 확인
        is_working_now = len(item_info) == 3 and 'names' in item_info and 'descriptions' in item_info and 'eids' in item_info
        
        if is_working_now:
            # WorkingNow 아이템은 names, descriptions, eids, gfx, workingnowflag만 출력
            js_content += f"""    {item_key}: {{
        gfx: "resources/gfx/items/collectibles/{item_key.lower()}.png",
        workingnowflag: true,
        names: {json.dumps(item_info['names'], ensure_ascii=False)},
        descriptions: {json.dumps(item_info['descriptions'], ensure_ascii=False)},
        eids: {json.dumps(item_info['eids'], ensure_ascii=False)}"""
        else:
            # 일반 아이템은 모든 필드 출력
            item_type = item_info.get('type', 'passive')
            # Path rule: use collectibles path for familiars as well
            if item_type == 'trinket':
                gfx_base = 'trinkets'
            else:
                gfx_base = 'collectibles'
            # custom gfx filename support
            gfx_name = item_info.get('gfx') or item_key.lower() + '.png'
            # Safe-encode string scalars using JSON to avoid broken quotes
            # Encode origin with type prefix for downstream ID resolution:
            #   Collectible/Familiar => C:
            #   Trinket => T:
            #   Card => K:
            #   Pill => P:
            origin_val = item_info.get('origin', '')
            if origin_val:
                origin_type = item_info.get('originType')
                if origin_type == 'trinket':
                    prefix = 'T'
                elif origin_type == 'card':
                    prefix = 'K'
                elif origin_type == 'pill':
                    prefix = 'P'
                else:
                    prefix = 'C'
                origin_encoded = f"{prefix}:{origin_val}"
            else:
                origin_encoded = ''
            origin_js = json.dumps(origin_encoded, ensure_ascii=False)
            flag_js = json.dumps(item_info.get('flag', ''), ensure_ascii=False)
            tags_js = json.dumps(item_info.get('tags', ''), ensure_ascii=False)
            cache_js = json.dumps(item_info.get('cache', ''), ensure_ascii=False)

            js_content += f"""    {item_key}: {{
        type: "{item_type}",
        gfx: "resources/gfx/items/{gfx_base}/{gfx_name}",
        tags: {tags_js},
        cache: {cache_js},
        hidden: {str(item_info.get('hidden', False)).lower()},
        shopprice: {item_info.get('shopprice', 0)},
        devilprice: {item_info.get('devilprice', 0)},
        maxcharges: {item_info.get('maxcharges', 0)},
        chargetype: "{item_info.get('chargetype', 'normal')}",
        initcharge: {item_info.get('initcharge', 0)},
        hearts: {item_info.get('hearts', 0)},
        maxhearts: {item_info.get('maxhearts', 0)},
        blackhearts: {item_info.get('blackhearts', 0)},
        soulhearts: {item_info.get('soulhearts', 0)},
        origin: {origin_js},
        flag: {flag_js}"""

            # entity/gibs for familiars
            if item_type == 'familiar':
                if 'entity' in item_info:
                    js_content += f",\n        entity: {json.dumps(item_info['entity'], ensure_ascii=False)}"
                if 'gibs' in item_info:
                    js_content += f",\n        gibs: {json.dumps(item_info['gibs'], ensure_ascii=False)}"

            # add pools/quality for collectibles-like items (including familiars)
            if item_type != 'trinket':
                # non-trinket: include quality and pools
                js_content += f",\n        quality: {item_info.get('quality', 3)}"
                js_content += f",\n        pools: {json.dumps(item_info.get('pools', []))}"
            
            # 일반 아이템에만 다국어 정보 추가
            if 'names' in item_info:
                js_content += f""",
        names: {json.dumps(item_info['names'], ensure_ascii=False)}"""
            
            if 'descriptions' in item_info:
                js_content += f""",
        descriptions: {json.dumps(item_info['descriptions'], ensure_ascii=False)}"""
            
            if 'eids' in item_info:
                js_content += f""",
        eids: {json.dumps(item_info['eids'], ensure_ascii=False)}"""
            
            # 시너지 정보 추가
            if 'synergies' in item_info:
                js_content += f""",
        synergies: {json.dumps(item_info['synergies'], ensure_ascii=False)}"""
                # 시너지 타입(collectible/trinket) 정보가 있으면 함께 출력
                if 'synergy_types' in item_info:
                    js_content += f",\n        synergy_types: {json.dumps(item_info['synergy_types'], ensure_ascii=False)}"
        
        js_content += """
    },
"""
    
    js_content += """};

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = items;
}

// Make available globally for browser
if (typeof window !== 'undefined') {
    window.items = items;
}
"""
    
    # 파일이 프로젝트 루트에 생성되므로 디렉토리 생성 불필요
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(js_content)
    
    print(f"items.js created: {output_path}")

def main():
    """main function"""
    lua_file = "scripts/conch_blessing_items.lua"
    items_js_path = "items.js"  # 프로젝트 루트에 생성
    
    print("Conch's Blessing Items.js Generator started...")
    print(f"reading Lua file: {lua_file}")
    
    # parse the Lua file
    items = parse_lua_file(lua_file)
    
    if not items:
        print("warning: no items found.")
        return
    
    print(f"found items: {len(items)}")
    for name, info in items.items():
        print(f"  - {name}: {info.get('name', 'Unknown')} (ID: {info.get('id', 'Unknown')})")
    
    # create the items.js file
    create_items_js(items, items_js_path)
    
    print("items.js file created!")

if __name__ == "__main__":
    main() 